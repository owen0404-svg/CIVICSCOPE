<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CivicScope | Urban Intelligence Platform</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Techy Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&family=Share+Tech+Mono&display=swap"
        rel="stylesheet">

    <style>
        /* Variabel Global: Techy Palette */
        :root {
            --primary: #00f2ff;
            /* Neon Cyan */
            --secondary: #7000ff;
            /* Neon Purple */
            --success: #00ff41;
            /* Matrix Green */
            --warning: #ffbe0b;
            /* Warning Yellow */
            --danger: #ff0055;
            /* Critical Red */

            /* Background lebih gelap untuk kontras neon */
            --bg-glass: rgba(5, 5, 16, 0.5);
            --border-glass: rgba(0, 242, 255, 0.3);

            /* Font Variables */
            --font-header: 'Orbitron', sans-serif;
            --font-body: 'Rajdhani', sans-serif;
            --font-mono: 'Share Tech Mono', monospace;
        }

        /* Reset CSS */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            overflow: hidden;
            background-color: #050505;
            font-family: var(--font-body);
            color: #e0e0e0;
        }

        #scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 3px,
                rgba(0, 0, 0, 0.15) 4px
            );
            z-index: 9999;
            opacity: 0.6;
        }

        /* Container untuk Render 3D */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }



        /* Layer UI */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            transform-origin: top left;
            will-change: transform;
        }

        .interactive {
            pointer-events: auto;
        }

        /* --- TECHY UI COMPONENT CLASSES --- */

        /* Cyber Border Effect */
        .cyber-panel {
            background: var(--bg-glass);
            border: 1px solid var(--border-glass);
            backdrop-filter: blur(10px);
            position: relative;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);
            border-radius: 0px;
        }

        /* Aksen sudut kiri atas */
        .cyber-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 10px;
            height: 10px;
            border-top: 2px solid var(--primary);
            border-left: 2px solid var(--primary);
            z-index: 2;
        }

        /* Aksen sudut kanan bawah */
        .cyber-panel::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 10px;
            height: 10px;
            border-bottom: 2px solid var(--primary);
            border-right: 2px solid var(--primary);
            z-index: 2;
        }

        /* Glitch Animation Text */
        .glitch-text {
            position: relative;
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0% {
                text-shadow: 2px 0 var(--secondary), -2px 0 var(--primary);
            }

            90% {
                text-shadow: 2px 0 var(--secondary), -2px 0 var(--primary);
            }

            91% {
                text-shadow: -2px 0 var(--secondary), 2px 0 var(--primary);
                transform: skewX(10deg);
            }

            92% {
                text-shadow: 2px 0 var(--secondary), -2px 0 var(--primary);
                transform: skewX(-10deg);
            }

            93% {
                transform: skewX(0deg);
            }

            100% {
                text-shadow: 2px 0 var(--secondary), -2px 0 var(--primary);
            }
        }

        /* Blinking Cursor for Terminal Effect */
        .blinking-cursor::after {
            content: '‚ñà';
            animation: blink 1s step-end infinite;
            margin-left: 5px;
            color: var(--primary);
            font-size: 0.8em;
        }

        /* --- GREEN INFRA PANEL --- */
        #green-panel {
            position: absolute;
            left: 2rem;
            top: 100px;
            width: 300px;
            padding: 1.5rem;
            background: var(--bg-glass);
            border: 1px solid var(--success);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none; /* Hidden by default */
        }

        #green-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid var(--success);
            border-left: 2px solid var(--success);
        }

        #green-panel::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 15px;
            height: 15px;
            border-bottom: 2px solid var(--success);
            border-right: 2px solid var(--success);
        }

        .green-option {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid rgba(0, 255, 65, 0.3);
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .green-option:hover {
            background: rgba(0, 255, 65, 0.2);
            border-color: var(--success);
        }

        .green-option.active {
            background: var(--success);
            color: black;
            font-weight: bold;
        }

        .green-title {
            font-family: var(--font-header);
            font-size: 0.9rem;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .green-desc {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            opacity: 0.8;
        }

        /* --- ENERGY GRID PANEL --- */
        #energy-panel {
            position: absolute;
            left: 340px; /* Right of green panel */
            top: 100px;
            width: 320px;
            padding: 1.5rem;
            background: var(--bg-glass);
            border: 1px solid #f1c40f;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.2);
            backdrop-filter: blur(15px);
            z-index: 101;
            display: none;
        }

        #energy-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid #f1c40f;
            border-left: 2px solid #f1c40f;
        }

        .energy-section {
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 1rem;
        }

        .energy-btn {
            background: rgba(241, 196, 15, 0.1);
            border: 1px solid rgba(241, 196, 15, 0.3);
            color: #f1c40f;
            padding: 8px 12px;
            width: 100%;
            text-align: left;
            margin-bottom: 8px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .energy-btn:hover, .energy-btn.active {
            background: #f1c40f;
            color: black;
            font-weight: bold;
        }

        .grid-meter {
            height: 6px;
            background: rgba(255,255,255,0.1);
            margin-top: 5px;
            position: relative;
        }
        
        .grid-meter-fill {
            height: 100%;
            background: #f1c40f;
            transition: width 0.5s ease;
        }

        /* --- LOGS PANEL --- */
        #logs-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            height: 450px;
            background: rgba(5, 8, 12, 0.92);
            border: 1px solid var(--primary);
            box-shadow: 
                0 0 30px rgba(0, 242, 255, 0.15),
                inset 0 0 20px rgba(0, 242, 255, 0.05);
            backdrop-filter: blur(12px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
        }
        
        #logs-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Scanline effect */
        #logs-panel::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
        }

        .panel-header {
            background: rgba(0, 242, 255, 0.1);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 242, 255, 0.3);
            z-index: 2;
        }

        .panel-title {
            font-family: var(--font-header);
            font-size: 0.9rem;
            letter-spacing: 2px;
            color: var(--primary);
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title::before {
            content: '';
            display: block;
            width: 8px;
            height: 8px;
            background: var(--primary);
            box-shadow: 0 0 5px var(--primary);
        }

        .close-btn {
            cursor: pointer;
            color: var(--primary);
            font-family: var(--font-mono);
            font-weight: bold;
            opacity: 0.7;
            transition: all 0.2s;
        }
        .close-btn:hover { 
            opacity: 1; 
            text-shadow: 0 0 8px var(--primary);
        }

        #logs-content {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            color: #d0e6ff;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) transparent;
            position: relative;
            z-index: 2;
            text-shadow: 0 0 2px rgba(0, 242, 255, 0.2);
        }

        #logs-content::-webkit-scrollbar {
            width: 6px;
        }
        #logs-content::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 0;
        }
        #logs-content::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
        }

        .log-entry {
            margin-bottom: 6px;
            line-height: 1.5;
            border-bottom: 1px solid rgba(255,255,255,0.03);
            padding-bottom: 4px;
            display: flex;
        }

        .log-entry.info { color: #5bc0de; }
        .log-entry.warn { color: #f0ad4e; }
        .log-entry.error { color: #d9534f; }
        .log-entry.system { color: var(--primary); font-weight: bold; border-bottom: 1px dashed rgba(0, 242, 255, 0.3); }
        .log-entry.success { color: #5cb85c; }

        .log-timestamp {
            color: rgba(255,255,255,0.4);
            margin-right: 12px;
            font-size: 0.75rem;
            min-width: 60px;
        }

        .logs-footer {
            padding: 8px 1rem;
            border-top: 1px solid rgba(0, 242, 255, 0.2);
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #888;
            background: rgba(0, 10, 15, 0.5);
            z-index: 2;
            display: flex;
            align-items: center;
        }
        
        .blink {
            animation: blinker 1s linear infinite;
            margin-right: 5px;
            color: var(--primary);
        }
        
        @keyframes blinker {
            50% { opacity: 0; }
        }

        /* --- HEADER --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .brand {
            font-family: var(--font-header);
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: white;
            text-shadow: 0 0 10px var(--primary);
            background: none;
            -webkit-text-fill-color: white;
        }

        /* UPDATED: Status Badge (No Box, Cleaner) */
        .status-badge {
            background: transparent;
            border: none;
            padding: 0;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: none;
            backdrop-filter: none;
            color: var(--primary);
            text-shadow: 0 0 8px rgba(0, 242, 255, 0.4);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
            animation: blink 1s step-end infinite;
            border-radius: 0;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }


        /* --- PANEL DETAIL KANAN --- */
        #detail-panel {
            position: absolute;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%) translateX(120%);
            width: 340px;
            padding: 1.5rem;
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            background: var(--bg-glass);
            border: 1px solid rgba(0, 242, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        /* Aksen sudut manual */
        #detail-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid var(--primary);
            border-left: 2px solid var(--primary);
        }

        #detail-panel::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 15px;
            height: 15px;
            border-bottom: 2px solid var(--primary);
            border-right: 2px solid var(--primary);
        }

        #detail-panel.active {
            transform: translateY(-50%) translateX(0);
        }

        .panel-header {
            border-bottom: 1px solid var(--border-glass);
            padding-bottom: 0.8rem;
            margin-bottom: 1.2rem;
        }

        .panel-title {
            font-family: var(--font-header);
            font-size: 1.4rem;
            color: white;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--primary);
        }

        .panel-subtitle {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--primary);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            margin-bottom: 1.2rem;
        }

        .stat-label {
            display: flex;
            justify-content: space-between;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            margin-bottom: 0.4rem;
            color: #aaa;
            text-transform: uppercase;
        }

        .progress-bar-bg {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 0;
        }

        .progress-bar-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 1s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 0 8px var(--primary);
        }

        .ai-insight {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #333;
            border-left: 3px solid var(--primary);
            padding: 1rem;
            margin-top: 1.5rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            line-height: 1.5;
            color: var(--primary);
        }

        .ai-title {
            font-weight: 700;
            color: white;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* --- CONTROLS (HUD BUTTONS) --- */
        #controls {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            padding-bottom: 4rem;
        }

        .hud-btn {
            background: var(--bg-glass);
            border: 1px solid var(--border-glass);
            color: var(--primary);
            padding: 0.8rem 2rem;
            border-radius: 0;
            cursor: pointer;
            font-family: var(--font-mono);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .hud-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
            z-index: -1;
        }

        .hud-btn:hover::before {
            width: 100%;
        }

        .hud-btn:hover {
            color: black;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            border-color: var(--primary);
        }

        .hud-btn.active {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 25px var(--primary);
        }

        /* --- STATS PANEL --- */
        #stats-panel {
            position: absolute;
            top: 100px;
            left: 2rem;
            width: 300px;
            max-height: calc(100vh - 250px); /* Prevent cutting off at bottom */
            overflow-y: auto; /* Allow scrolling if content is too long */
            overflow-x: hidden; /* Prevent horizontal scroll */
            word-wrap: break-word; /* Ensure text wraps */
            background: var(--bg-glass);
            border: 1px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            transition: opacity 0.3s ease;
            z-index: 100;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--primary) rgba(0,0,0,0.3);
        }
        
        #stats-panel::-webkit-scrollbar {
            width: 6px;
        }
        #stats-panel::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: var(--primary);
        }

        #stats-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid var(--primary);
            border-left: 2px solid var(--primary);
        }

        #stats-panel::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 15px;
            height: 15px;
            border-bottom: 2px solid var(--primary);
            border-right: 2px solid var(--primary);
        }

        #stats-panel.hidden {
            display: none;
            opacity: 0;
            pointer-events: none;
        }

        .stats-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.2rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid #333;
        }

        .stats-panel-title {
            font-family: var(--font-header);
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stats-close-btn {
            cursor: pointer;
            font-size: 1rem;
            color: var(--primary);
            opacity: 0.7;
            transition: all 0.2s;
        }

        .stats-close-btn:hover {
            opacity: 1;
            text-shadow: 0 0 5px var(--primary);
        }

        .stat-item {
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            border-bottom: 1px dashed #222;
            padding-bottom: 0.5rem;
        }

        .stat-name {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-family: var(--font-header);
            font-size: 1.2rem;
            color: white;
        }

        .stat-unit {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--primary);
        }

        .city-stat-item {
            margin-bottom: 1.2rem;
            padding: 0;
            background: transparent;
            border: none;
        }

        .city-stat-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--primary);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
        }

        .city-stat-progress {
            width: 100%;
            height: 2px;
            background: #222;
            margin-top: 0.2rem;
        }

        .city-stat-progress-fill {
            height: 100%;
            background: var(--primary);
            box-shadow: 0 0 5px var(--primary);
        }

        .total-score {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-glass);
            text-align: center;
        }

        .total-score-label {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 0.5rem;
        }

        .total-score-value {
            font-family: var(--font-header);
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 15px var(--success);
            background: none;
            -webkit-text-fill-color: white;
        }

        /* --- LOADER --- */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .loader-text {
            font-family: var(--font-header);
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 8px;
            color: white;
            text-shadow: 0 0 20px var(--primary);
            animation: glitch 1s infinite;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            color: var(--primary);
            font-family: sans-serif;
        }

        /* --- CONTROLS HELP --- */
        #controls-help {
            position: absolute;
            bottom: 4rem;
            right: 2rem;
            width: 300px;
            background: var(--bg-glass);
            border: 1px solid rgba(0, 242, 255, 0.3);
            border-radius: 0;
            padding: 1.5rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #ccc;
            transition: opacity 0.3s ease;
            z-index: 20;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        #controls-help::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid var(--primary);
            border-left: 2px solid var(--primary);
        }

        #controls-help::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 15px;
            height: 15px;
            border-bottom: 2px solid var(--primary);
            border-right: 2px solid var(--primary);
        }

        #controls-help.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .controls-title {
            font-family: var(--font-header);
            font-size: 0.9rem;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 242, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .controls-title::before {
            content: '';
            display: block;
            width: 8px;
            height: 8px;
            background: var(--primary);
            box-shadow: 0 0 5px var(--primary);
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 0.4rem;
        }

        .control-key {
            background: rgba(0, 242, 255, 0.1);
            border: 1px solid rgba(0, 242, 255, 0.3);
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 0;
            font-family: var(--font-mono);
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        /* UPDATED: Toggle Buttons & Position */
        #toggle-stats,
        #toggle-help,
        #toggle-transit,
        #toggle-weather {
            position: absolute;
            background: black;
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 0.6rem 1.2rem;
            border-radius: 0;
            cursor: pointer;
            font-family: var(--font-mono);
            text-transform: uppercase;
            font-size: 0.7rem;
            transition: all 0.3s ease;
            z-index: 21;
        }

        #toggle-weather:hover,
        #toggle-stats:hover,
        #toggle-help:hover,
        #toggle-transit:hover {
            background: var(--primary);
            color: black;
            box-shadow: 0 0 15px var(--primary);
        }

        #toggle-help {
            bottom: 4rem;
            right: 2rem;
        }

        #toggle-transit {
            top: 100px;
            right: 2rem;
        }

        /* Moved to top left to match panel position */
        #toggle-stats {
            top: 160px;
            bottom: auto;
            left: 2rem;
            transform: none;
            z-index: 90;
        }

        #toggle-weather {
            bottom: 4rem;
            left: 2rem;
        }

        /* UPDATED: Techy Bottom Bar (Subtle) */
        .bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 36px;
            /* Gradient background to be more subtle */
            background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0) 100%);
            /* Very transparent top border */
            border-top: 1px solid rgba(0, 242, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: #888;
            z-index: 15;
            backdrop-filter: blur(2px);
            pointer-events: auto;
        }

        .bar-label {
            color: var(--primary);
            letter-spacing: 1px;
            font-weight: 700;
            opacity: 0.9;
        }

        .bar-sep {
            margin: 0 10px;
            color: #444;
        }

        .bar-line {
            flex-grow: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(0, 242, 255, 0.3), transparent);
            margin: 0 20px;
        }
        /* New Detailed Metrics Styles */
        .detailed-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .metric-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 242, 255, 0.2);
            padding: 8px;
            border-radius: 4px;
        }

        .metric-title {
            font-family: var(--font-header);
            font-size: 0.7rem;
            color: var(--primary);
            text-transform: uppercase;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(0, 242, 255, 0.2);
            padding-bottom: 2px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 3px;
            color: #ccc;
        }

        .metric-row span:last-child {
            font-family: var(--font-mono);
            color: #fff;
            font-weight: bold;
        }

        /* AI Analyst Section */
        .ai-analyst-section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed var(--border-glass);
        }

        .cyber-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-glass);
            color: var(--primary);
            font-family: var(--font-mono);
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            outline: none;
            transition: all 0.3s;
        }

        .cyber-input:focus {
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.3);
            border-color: var(--primary);
        }

        .cyber-button {
            width: 100%;
            background: rgba(0, 242, 255, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            font-family: var(--font-header);
            text-transform: uppercase;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .cyber-button:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 15px var(--primary);
        }

        .ai-output {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 2px solid var(--secondary);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #e0e0e0;
            min-height: 60px;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            line-height: 1.4;
        }
        
        .ai-output::-webkit-scrollbar {
            width: 4px;
        }
        
        .ai-output::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3); 
        }
        
        .ai-output::-webkit-scrollbar-thumb {
            background: var(--secondary); 
        }

        /* --- TRANSIT PANEL --- */
        #transit-panel {
            position: absolute;
            right: 2rem;
            top: 100px; /* Below header */
            width: 300px;
            padding: 1.5rem;
            background: var(--bg-glass);
            border: 1px solid rgba(0, 242, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #transit-panel::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            width: 15px;
            height: 15px;
            border-top: 2px solid var(--primary);
            border-left: 2px solid var(--primary);
        }

        #transit-panel::after {
            content: '';
            position: absolute;
            bottom: -1px;
            right: -1px;
            width: 15px;
            height: 15px;
            border-bottom: 2px solid var(--primary);
            border-right: 2px solid var(--primary);
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: #aaa;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }
    </style>
</head>

<body>



    <div id="loader">
        <div class="loader-text glitch-text">CIVICSCOPE</div>
        <div
            style="margin-top: 10px; font-family: 'Share Tech Mono'; font-size: 0.8rem; color: #00f2ff; letter-spacing: 2px;">
            INITIALIZING NEURAL GRID...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header class="interactive">
            <div class="brand glitch-text">
            <a href="index.html" style="text-decoration: none; color: inherit;">
                Civic<span style="color:var(--primary)">Scope</span>
            </a>
            </div>
            <!-- UPDATED STATUS BADGE: Clean text only -->
            <div class="status-badge">
                <div class="status-dot"></div>
                LIVE SIMULATION // CONNECTED
            </div>
        </header>

        <!-- Transit Optimization Panel -->
        <div id="transit-panel" class="interactive">
            <div class="close-btn" onclick="toggleTransitPanel()">[X]</div>
            <div class="panel-header">
                <div class="panel-title">Transit Optimization</div>
                <div class="panel-subtitle">Route Analysis System</div>
            </div>
            
            <div class="control-group">
                <label for="transit-mode">Transit Mode</label>
                <select id="transit-mode" class="cyber-input">
                    <option value="bus">Bus Network</option>
                    <option value="rail">Light Rail</option>
                    <option value="metro">Metro / Subway</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="btn-generate-routes" class="cyber-button" onclick="generateTransitRoutes()">
                    GENERATE ROUTES
                </button>
            </div>

            <div id="route-stats" class="ai-output" style="display:none; height: auto; min-height: 40px;">
                <!-- Stats will appear here -->
            </div>
        </div>

        <!-- Green Infra Analysis Panel -->
        <div id="green-panel" class="interactive">
            <div class="panel-header">
                <div class="panel-title" style="color:var(--success)">Eco-Analysis</div>
                <div class="panel-subtitle">Green Infrastructure Deployment</div>
            </div>

            <div id="opt-energy-grid" class="green-option" onclick="openEnergyGridPanel()">
                <div class="green-title">‚ö° Smart Energy Grid</div>
                <div class="green-desc">Manage city-wide power generation, distribution, and storage systems.</div>
            </div>

            <div id="opt-garden" class="green-option" onclick="deployGreenTech('garden')">
                <div class="green-title">Roof Gardens</div>
                <div class="green-desc">Convert flat roofs to green spaces. Reduces heat island effect.</div>
            </div>

            <div id="opt-vertical" class="green-option" onclick="deployGreenTech('vertical')">
                <div class="green-title">Vertical Forests</div>
                <div class="green-desc">Apply vegetation to building facades. Filters air pollution.</div>
            </div>

            <div id="green-stats" class="ai-output" style="display:none; height: auto; min-height: 40px; color: var(--success); border-color: var(--success);">
                <!-- Analysis results -->
            </div>

            <!-- GRID MONITOR -->
            <div id="grid-monitor" style="display:none; margin-top: 15px; border-top: 1px dashed var(--success); padding-top: 10px;">
                <div class="green-title" style="color:#f1c40f">‚ö° CITY POWER GRID</div>
                
                <div style="display:flex; justify-content:space-between; margin-bottom:5px; font-size:0.7rem; font-family:var(--font-mono);">
                    <span>DEMAND:</span>
                    <span id="grid-demand" style="color:#e74c3c">0 MW</span>
                </div>
                <div class="progress-bar-bg">
                    <div id="bar-demand" class="progress-bar-fill" style="width: 0%; background: #e74c3c;"></div>
                </div>

                <div style="display:flex; justify-content:space-between; margin:5px 0; font-size:0.7rem; font-family:var(--font-mono);">
                    <span>RENEWABLE:</span>
                    <span id="grid-renewable" style="color:#2ecc71">0 MW</span>
                </div>
                <div class="progress-bar-bg">
                    <div id="bar-renewable" class="progress-bar-fill" style="width: 0%; background: #2ecc71;"></div>
                </div>

                <div style="margin-top:8px; font-size:0.7rem; color:#aaa; text-align:center;">
                    GRID STATUS: <span id="grid-status" style="color:white">STABLE</span>
                </div>
            </div>
        </div>

        <!-- Detail Panel (Updated Classes) -->
        
        <!-- ENERGY GRID ADVANCED PANEL -->
        <div id="energy-panel" class="interactive">
            <div class="close-btn" onclick="closeEnergyGridPanel()">[X]</div>
            <div class="panel-header">
                <div class="panel-title" style="color:#f1c40f">Energy Command</div>
                <div class="panel-subtitle">Generation & Storage Management</div>
            </div>

            <!-- GENERATION -->
            <div class="energy-section">
                <div class="green-title" style="margin-bottom:10px">RENEWABLE GENERATION</div>
                
                <div id="btn-solar-roof" class="energy-btn" onclick="deployGreenTech('solar')">
                    <span>‚òÄÔ∏è Solar Roof Retrofit</span>
                    <span id="count-solar">0 Units</span>
                </div>
                
                <div id="btn-wind-farm" class="energy-btn" onclick="deployWindFarm()">
                    <span>üí® Offshore Wind Farm</span>
                    <span id="count-wind">0 Units</span>
                </div>
            </div>

            <!-- STORAGE -->
            <div class="energy-section">
                <div class="green-title" style="margin-bottom:10px">GRID STORAGE</div>
                
                <div id="btn-battery" class="energy-btn" onclick="deployBatteries()">
                    <span>üîã Grid Battery Banks</span>
                    <span id="count-battery">0 Units</span>
                </div>
                
                <div style="margin-top:10px; font-size:0.7rem;">
                    <div>STORAGE CAPACITY</div>
                    <div class="grid-meter">
                        <div id="meter-storage" class="grid-meter-fill" style="width:0%"></div>
                    </div>
                    <div id="text-storage" style="text-align:right; color:#aaa;">0 MWh</div>
                </div>
            </div>

            <!-- REAL-TIME LOAD -->
            <div>
                 <div class="green-title">REAL-TIME LOAD BALANCE</div>
                 <div style="display:flex; justify-content:space-between; font-size:0.7rem; margin-top:5px; color:#aaa;">
                     <span>GENERATION</span>
                     <span>CONSUMPTION</span>
                 </div>
                 <div class="grid-meter" style="height:10px; background:#333; overflow:hidden;">
                     <!-- Split bar: Left Green (Gen), Right Red (Load) -->
                     <div id="balance-bar" style="position:absolute; left:50%; width:2px; height:100%; background:white; z-index:2"></div>
                     <div id="load-fill" style="position:absolute; right:50%; width:0%; height:100%; background:#e74c3c; opacity:0.8"></div>
                     <div id="gen-fill" style="position:absolute; left:50%; width:0%; height:100%; background:#2ecc71; opacity:0.8"></div>
                 </div>
                 <div id="balance-text" style="text-align:center; font-size:0.7rem; margin-top:5px; color:white;">GRID STABLE</div>
            </div>
        </div>

        <div id="detail-panel" class="interactive">
            <div class="close-btn" onclick="closePanel()">[X]</div>
            <div class="panel-header">
                <div class="panel-title" id="b-id">SECTOR #402</div>
                <div class="panel-subtitle" id="b-type">Commercial Node</div>
            </div>

            <div class="stat-row">
                <div class="stat-label">
                    <span>Pollution Output</span>
                    <span id="val-pol" style="color:var(--danger)">78%</span>
                </div>
                <div class="progress-bar-bg">
                    <div class="progress-bar-fill" id="bar-pol" style="background: var(--danger);"></div>
                </div>
            </div>

            <div class="stat-row">
                <div class="stat-label">
                    <span>Energy Efficiency</span>
                    <span id="val-en" style="color:var(--warning)">Low</span>
                </div>
                <div class="progress-bar-bg">
                    <div class="progress-bar-fill" id="bar-en" style="background: var(--warning);"></div>
                </div>
            </div>

            <div class="stat-row">
                <div class="stat-label">
                    <span>Traffic Impact</span>
                    <span id="val-traf" style="color:var(--secondary)">High</span>
                </div>
                <div class="progress-bar-bg">
                    <div class="progress-bar-fill" id="bar-traf" style="background: var(--secondary);"></div>
                </div>
            </div>

            <div class="stat-row">
                <div class="stat-label">
                    <span>Security Index</span>
                    <span id="val-sec" style="color:var(--success)">0%</span>
                </div>
                <div class="progress-bar-bg">
                    <div class="progress-bar-fill" id="bar-sec" style="background: var(--success);"></div>
                </div>
            </div>

            <div class="ai-insight">
                <div class="ai-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z">
                        </path>
                    </svg>
                    AI ANALYSIS
                </div>
                <span id="ai-text">Scanning structural integrity... Grid alignment optimal.</span>
            </div>
        </div>

        <div id="controls" class="interactive">
            <button class="hud-btn" id="btn-traffic" onclick="toggleScenario('traffic')">Optimize Traffic</button>
            <button class="hud-btn" id="btn-logs" onclick="toggleLogsPanel()">System Logs</button>
            <button class="hud-btn" id="btn-green" onclick="toggleScenario('green')">Green Infra</button>
            <button class="hud-btn" id="btn-pop" onclick="togglePopulationStats()">Population Stats</button>
        </div>

        <!-- LOGS PANEL -->
        <div id="logs-panel" class="interactive">
            <div class="panel-header">
                <div class="panel-title">SYSTEM TERMINAL</div>
                <div class="close-btn" onclick="toggleLogsPanel()">[X]</div>
            </div>
            <div id="logs-content">
                <div class="log-entry system">[SYSTEM INIT] Core modules loaded.</div>
            </div>
            <div class="logs-footer">
                <span class="blink">_</span> WAITING FOR INPUT...
            </div>
        </div>

        <!-- Stats Panel -->
        <div id="stats-panel" class="interactive">
            <div class="stats-panel-header">
                <div class="stats-panel-title">City Metrics</div>
                <div class="stats-close-btn" onclick="toggleStatsPanel()" title="Close Panel">‚úï</div>
            </div>

            <!-- Basic Stats -->
            <div class="stat-item">
                <div class="stat-name">Structures</div>
                <div class="stat-value" id="stat-buildings">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">Active Units</div>
                <div class="stat-value" id="stat-vehicles">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">System Time</div>
                <div class="stat-value" id="stat-time">12:00</div>
                <span class="stat-unit" id="stat-period">UTC</span>
            </div>
            <div class="stat-item">
                <div class="stat-name">Atmosphere</div>
                <div class="stat-value" id="stat-weather" style="font-size: 1rem; color:var(--success)">CLEAR</div>
            </div>

            <!-- Detailed Metrics (New) -->
            <div class="detailed-metrics">
                <!-- Population -->
                <div class="metric-section">
                    <div class="metric-title">Demographics</div>
                    <div class="metric-row">
                        <span>Population</span>
                        <span id="metric-population">0</span>
                    </div>
                     <div class="metric-row">
                        <span>Capacity</span>
                        <span id="metric-capacity">0</span>
                    </div>
                </div>
                <!-- Economics -->
                <div class="metric-section">
                    <div class="metric-title">Economy</div>
                    <div class="metric-row">
                        <span>Jobs</span>
                        <span id="metric-jobs">0</span>
                    </div>
                     <div class="metric-row">
                        <span>Commercial</span>
                        <span id="metric-commercial">0</span>
                    </div>
                </div>
                <!-- Infrastructure -->
                <div class="metric-section">
                    <div class="metric-title">Infrastructure</div>
                    <div class="metric-row">
                        <span>Power Usage</span>
                        <span id="metric-power">0 MW</span>
                    </div>
                     <div class="metric-row">
                        <span>Water Demand</span>
                        <span id="metric-water">0 ML</span>
                    </div>
                </div>
                 <!-- Environment -->
                <div class="metric-section">
                    <div class="metric-title">Environment</div>
                    <div class="metric-row">
                        <span>Air Quality</span>
                        <span id="metric-air">100%</span>
                    </div>
                     <div class="metric-row">
                        <span>Green Space</span>
                        <span id="metric-green">0%</span>
                    </div>
                </div>
            </div>

            <!-- City Total Statistics -->
            <div class="city-stat-item">
                <div class="city-stat-label">
                    <span>Grid Efficiency</span>
                    <span id="city-energy-value">0%</span>
                </div>
                <div class="city-stat-progress">
                    <div class="city-stat-progress-fill" id="city-energy-bar" style="width: 0%;"></div>
                </div>
            </div>

            <div class="city-stat-item">
                <div class="city-stat-label">
                    <span>Carbon Filters</span>
                    <span id="city-pollution-value">0%</span>
                </div>
                <div class="city-stat-progress">
                    <div class="city-stat-progress-fill" id="city-pollution-bar" style="width: 0%;"></div>
                </div>
            </div>
            
            <div class="city-stat-item">
                <div class="city-stat-label">
                    <span>Security Coverage</span>
                    <span id="city-security-value">0%</span>
                </div>
                <div class="city-stat-progress">
                    <div class="city-stat-progress-fill" id="city-security-bar" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Total Score -->
            <div class="total-score">
                <div class="total-score-label">Sustainability Index</div>
                <div class="total-score-value glitch-text" id="city-total-score">0%</div>
            </div>

            <!-- AI Analyst Section (New) -->
            <div class="ai-analyst-section">
                <div class="metric-title">AI City Analyst</div>
                <input type="password" id="openai-api-key" placeholder="Enter OpenAI API Key" class="cyber-input">
                <button onclick="generateAIReport()" class="cyber-button">Analyze City Data</button>
                <div id="ai-report-output" class="ai-output">System waiting for analysis request...</div>
            </div>
        </div>

        <!-- Toggle Stats Panel Button (Moved to bottom left) -->
        <button id="toggle-stats" class="interactive" onclick="toggleStatsPanel()">
            SHOW DATA
        </button>

        <!-- Day/Night Toggle Button -->
        <button id="toggle-weather" class="interactive" onclick="toggleDayNight()">DAY / NIGHT</button>

        <!-- Controls Help Panel -->
        <button id="toggle-help" class="interactive" onclick="toggleControlsHelp()">CONTROLS</button>
        <button id="toggle-transit" class="interactive" onclick="toggleTransitPanel()" style="display: none;">TRANSIT</button>

        <div id="controls-help" class="interactive hidden">
            <div class="controls-title">Navigation Systems</div>
            <div class="control-item">
                <span>Rotate</span>
                <span class="control-key">LMB</span>
            </div>
            <div class="control-item">
                <span>Pan</span>
                <span class="control-key">RMB</span>
            </div>
            <div class="control-item">
                <span>Zoom</span>
                <span class="control-key">Scroll</span>
            </div>
            <div style="margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid #333;">
                <div class="control-item">
                    <span>Inspect Node</span>
                    <span class="control-key">Hover</span>
                </div>
            </div>
            <button onclick="toggleControlsHelp()"
                style="margin-top: 0.8rem; width: 100%; padding: 0.4rem; background: rgba(0,242,255,0.1); border: 1px solid var(--border-glass); color: var(--primary); cursor: pointer; font-size: 0.7rem; font-family:var(--font-mono); text-transform: uppercase;">MINIMIZE</button>
        </div>

        <!-- Techy Bottom Bar (Subtle) -->
        <div class="bottom-bar interactive">
            <div class="flex items-center gap-4">
                <span class="bar-label">SYSTEM INTEGRITY: 100%</span>
                <span class="bar-sep">|</span>
                <span class="bar-label">LAT: 34.05N LONG: 118.24W</span>
            </div>
            <div class="bar-line"></div>
            <div>
                <span class="bar-label blinking-cursor">PROCESSING DATA STREAM...</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        function reportFatal(message) {
            const box = document.createElement('div');
            box.style.position = 'fixed';
            box.style.top = '20px';
            box.style.left = '50%';
            box.style.transform = 'translateX(-50%)';
            box.style.background = '#200';
            box.style.color = '#ffaaaa';
            box.style.border = '1px solid #a00';
            box.style.padding = '10px 14px';
            box.style.zIndex = '9999';
            box.style.fontFamily = 'monospace';
            box.textContent = message;
            document.body.appendChild(box);
        }
        window.addEventListener('error', (e) => {
            reportFatal('Runtime error: ' + (e.message || 'Unknown'));
        });
        if (!window.THREE) {
            reportFatal('Failed to load three.js library from CDN.');
        }
        if (window.THREE && !THREE.OrbitControls) {
            reportFatal('Failed to load OrbitControls from CDN.');
        }
        // --- 1. KONFIGURASI & STATE (DATA) ---
        const config = {
            gridSize: 80,               // Ukuran grid kota (40x40 kotak)
            cellSize: 15,               // Ukuran satu kotak tanah/jalan
            highlightColor: 0x00f0ff,   // Warna saat gedung dipilih (Cyan)
            solarColor: 0x1133aa,       // Warna gedung saat mode Solar aktif
            greenColor: 0x228b22,       // Warna gedung saat mode Green aktif
            // Sky colors (fog removed)
            skyNightColor: 0x1a1a2e,
            skyDayColor: 0x87ceeb,
            // Pengaturan siklus siang-malam
            // Terrain settings
            terrainSize: 6000,
            terrainSegments: 300,
            hillHeight: 180,
            terrainTreeCount: 2000,
            seaLevel: -25,
            waterSizeMultiplier: 3,
            dayNight: {
                fullDaySeconds: 120,     // Lama 1 siklus siang-malam (dalam detik)
                minSunIntensity: 0.05,   // Darker night sun
                maxSunIntensity: 1.0,    // Reduced max brightness (was 1.6)
                minAmbientIntensity: 0.05, // Darker night ambient
                maxAmbientIntensity: 0.45  // Reduced max ambient (was 0.7)
            },
            // Pengaturan cuaca dinamis
            weather: {
                changeIntervalSeconds: 45,   // Seberapa sering cuaca berganti (dipersingkat agar lebih sering terlihat)
                cloudDarkenStrength: 0.65,   // Seberapa gelap saat mendung
                rainDarkenStrength: 0.85,    // Seberapa gelap saat hujan
                maxCloudOpacity: 0.6,       // Opasitas maksimum awan (lebih pekat)
                rainDropCount: 6000,         // Jumlah partikel hujan (lebih banyak, lebih jelas)
                rainAreaMultiplier: 1.4     // Seberapa lebar area hujan dibanding kota
            },
            buildingPalette: [          // Daftar warna acak untuk gedung (lebih banyak warna)
                0x2c3e50, 0x34495e, 0x5d6d7e, 0x85929e, 0x1c2833, // biru keabu-abuan
                0x1b4f72, 0x154360, 0x196f3d, 0x117a65, 0x7d6608, // hijau & emas
                0x6c3483, 0x512e5f, 0x922b21, 0x7b241c, 0x4a235a  // ungu & merah bata
            ]
        };

        // State menyimpan kondisi aplikasi saat ini
        const state = {
            activeScenario: { solar: false, traffic: false, green: false }, // Status tombol
            selectedObject: null, // Objek gedung yang sedang diklik
            hoveredObject: null   // Objek gedung yang sedang disorot mouse
        };

        // Clock untuk menghitung delta time (dipakai siklus siang-malam)
        const clock = new THREE.Clock();

        // --- 2. SETUP THREE.JS ---
        const container = document.getElementById('canvas-container');
        const uiLayer = document.getElementById('ui-layer');
        if (!container) {
            reportFatal('Missing #canvas-container element.');
        }
        if (!uiLayer) {
            reportFatal('Missing #ui-layer element.');
        }
        const scene = new THREE.Scene(); // Membuat dunia 3D baru

        function updateUIScale() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const scaleByW = w / 1400;
            const scaleByH = h / 900;
            const scale = THREE.MathUtils.clamp(Math.min(scaleByW, scaleByH), 0.62, 1);

            uiLayer.style.transform = `scale(${scale})`;
            uiLayer.style.width = `${100 / scale}%`;
            uiLayer.style.height = `${100 / scale}%`;
        }
        updateUIScale();

        // Mengatur background dan kabut sesuai setting original
        const nightSkyColor = new THREE.Color(config.skyNightColor);
        const daySkyColor = new THREE.Color(config.skyDayColor);
        scene.background = nightSkyColor.clone();

        // Membuat kamera (PerspectiveCamera meniru mata manusia)
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 6000);
        camera.position.set(300, 250, 300); // Posisi awal kamera (x, y, z)

        // Membuat renderer (alat penggambar grafik ke layar)
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight); // Ukuran full screen
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Resolusi tajam
        renderer.shadowMap.enabled = true; // Mengaktifkan bayangan
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Tipe bayangan lembut
        container.appendChild(renderer.domElement); // Masukkan canvas ke HTML

        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.0,
            0.55,
            0.75
        );
        bloomPass.enabled = true;
        composer.addPass(bloomPass);

        const bloomState = {
            cooldown: 8,
            pulseRemaining: 0,
            pulseDuration: 1.4
        };
        let lastDayFactor = 0;

        // Kontrol Orbit (Bisa putar/zoom dengan mouse)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Pergerakan halus (ada inersia)
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Batas putar bawah (agar tidak tembus tanah)
        controls.minDistance = 50;     // Jarak zoom terdekat
        controls.maxDistance = 1200;    // Jarak zoom terjauh

        // --- WASD CAMERA CONTROLS ---
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            q: false,
            e: false
        };

        const cameraSpeed = 0.5; // Speed multiplier for camera movement

        // Keyboard event listeners
        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                event.preventDefault();
            }
        });

        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
                event.preventDefault();
            }
        });

        // Function to update camera position based on WASD keys
        function updateCameraMovement(delta) {
            const moveSpeed = cameraSpeed * delta * 60; // Normalize by delta time

            // Get camera direction vectors (create new vectors to avoid modifying originals)
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; // Keep movement horizontal
            direction.normalize();

            // Right vector (perpendicular to forward)
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();

            // Movement vector
            const moveVector = new THREE.Vector3();

            if (keys.w) {
                const forward = direction.clone();
                moveVector.add(forward.multiplyScalar(moveSpeed));
            }
            if (keys.s) {
                const backward = direction.clone();
                moveVector.add(backward.multiplyScalar(-moveSpeed));
            }
            if (keys.a) {
                const left = right.clone();
                moveVector.add(left.multiplyScalar(-moveSpeed));
            }
            if (keys.d) {
                const rightDir = right.clone();
                moveVector.add(rightDir.multiplyScalar(moveSpeed));
            }
            if (keys.q) {
                moveVector.y += moveSpeed;
            }
            if (keys.e) {
                moveVector.y -= moveSpeed;
            }

            // Apply movement
            camera.position.add(moveVector);
            controls.target.add(moveVector); // Move orbit target too
        }

        // --- 3. PENCAHAYAAN (LIGHTING) ---
        // Cahaya Hemisphere (Cahaya lingkungan umum, seperti langit)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444466, 0.6);
        scene.add(hemiLight);

        // Cahaya Directional (Seperti Matahari, menghasilkan bayangan)
        const dirLight = new THREE.DirectionalLight(0xffdfba, 1.5);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true; // Cahaya ini bikin bayangan
        // Mengatur kualitas bayangan
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 350; // Area cakupan bayangan
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // Cahaya Ambient (Cahaya dasar agar bagian gelap tidak hitam total)
const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        // Lampu hias Neon 1 (Cyan)
        const pointLight = new THREE.PointLight(0x00f0ff, 1, 400);
        pointLight.position.set(0, 50, 0);
        scene.add(pointLight);

        // Lampu hias Neon 2 (Pink)
        const secondaryLight = new THREE.PointLight(0xff00aa, 0.8, 400);
        secondaryLight.position.set(-50, 60, -50);
        scene.add(secondaryLight);

// --- 4. GENERASI KOTA ---
        const buildings = []; // Array untuk menyimpan semua objek gedung
        const cars = [];      // Array untuk menyimpan semua objek mobil
        const trees = [];     // Array untuk menyimpan semua objek pohon
        const lampposts = []; // Array untuk menyimpan semua lampu jalan
        const lampLights = []; // Array untuk menyimpan sumber cahaya lampu jalan
        const policeStations = []; // Daftar bangunan kantor polisi untuk indeks keamanan
        const cloudMeshes = [];   // Awan 2D semi transparan di langit
        const raindrops = [];     // Partikel hujan
        const roadGroup = new THREE.Group(); // Grup khusus jalanan
        scene.add(roadGroup);
        const sidewalkPropGroup = new THREE.Group();
        scene.add(sidewalkPropGroup);
        let cityRoadMap = []; // Global road map for car navigation

        const maxWindowInstances = 150000;
        const windowGeometry = new THREE.BoxGeometry(1.25, 1.25, 0.16);
        const windowMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 });
        const windowMesh = new THREE.InstancedMesh(windowGeometry, windowMaterial, maxWindowInstances);
        windowMesh.frustumCulled = false;
        scene.add(windowMesh);
        const windowDummy = new THREE.Object3D();
let windowInstanceCount = 0;

        const maxSkyscraperWindowInstances = 140000;
        const skyscraperWindowGeometry = new THREE.BoxGeometry(0.9, 1.9, 0.14);
        const skyscraperWindowMaterial = new THREE.MeshBasicMaterial({ color: 0xf2fbff, transparent: true, opacity: 0.22 });
        const skyscraperWindowMesh = new THREE.InstancedMesh(skyscraperWindowGeometry, skyscraperWindowMaterial, maxSkyscraperWindowInstances);
        skyscraperWindowMesh.frustumCulled = false;
        scene.add(skyscraperWindowMesh);
        const skyscraperWindowDummy = new THREE.Object3D();
        let skyscraperWindowInstanceCount = 0;

        function addRooftopDetails(building, width, depth, height) {
            const numDetails = Math.floor(Math.random() * 4) + 1;
            const roofMat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                roughness: 0.9,
                metalness: 0.3
            });
            
            for (let i = 0; i < numDetails; i++) {
                const type = Math.random();
                if (type < 0.5) {
                    // AC Unit / Vent Box
                    const w = Math.random() * (width * 0.25) + 0.5;
                    const d = Math.random() * (depth * 0.25) + 0.5;
                    const h = Math.random() * 1.2 + 0.5;
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, roofMat);
                    mesh.position.set(
                        (Math.random() - 0.5) * (width - w),
                        height + h / 2,
                        (Math.random() - 0.5) * (depth - d)
                    );
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    building.add(mesh);
                } else if (type < 0.8 && height > 20) {
                    // Thin Antenna
                    const h = Math.random() * 4 + 2;
                    const geo = new THREE.CylinderGeometry(0.05, 0.05, h);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
                    mesh.position.set(
                        (Math.random() - 0.5) * (width * 0.6),
                        height + h / 2,
                        (Math.random() - 0.5) * (depth * 0.6)
                    );
                    building.add(mesh);
                } else {
                    // Cylindrical Tank
                    const r = Math.random() * 0.8 + 0.4;
                    const h = Math.random() * 1.5 + 0.8;
                    const geo = new THREE.CylinderGeometry(r, r, h, 16);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0x9999aa}));
                    mesh.position.set(
                        (Math.random() - 0.5) * (width - r * 2),
                        height + h / 2,
                        (Math.random() - 0.5) * (depth - r * 2)
                    );
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    building.add(mesh);
                }
            }
        }

        function addFacadeDetails(building, width, depth, height, style, isSkyscraper) {
            // Add darker detail material
            const detailMat = building.material.clone();
            detailMat.color.offsetHSL(0, 0, -0.15); 
            
            if (isSkyscraper) {
                // Vertical Ribs for Skyscrapers
                const ribCount = Math.floor(width / 3) + 2;
                const spacing = width / ribCount;
                for(let i = 0; i <= ribCount; i++) {
                    const x = -width/2 + i * spacing;
                    const ribW = 0.3;
                    const ribD = 0.3;
                    const geo = new THREE.BoxGeometry(ribW, height, ribD);
                    // Translate so origin is at bottom (relative to building mesh origin, which is at bottom)
                    geo.translate(0, height/2, 0); 
                    
                    const meshFront = new THREE.Mesh(geo, detailMat);
                    meshFront.position.set(x, 0, depth/2);
                    building.add(meshFront);
                    
                    const meshBack = new THREE.Mesh(geo, detailMat);
                    meshBack.position.set(x, 0, -depth/2);
                    building.add(meshBack);
                }
            } else if (style === 'standard' || style === 'residential') {
                // Horizontal Bands / Balconies
                const floorHeight = 3.5;
                const numFloors = Math.floor(height / floorHeight);
                for(let i = 1; i < numFloors; i++) {
                    const y = i * floorHeight;
                    // Ledge
                    const ledgeGeo = new THREE.BoxGeometry(width + 0.4, 0.3, depth + 0.4);
                    const ledge = new THREE.Mesh(ledgeGeo, detailMat);
                    ledge.position.y = y;
                    ledge.castShadow = true;
                    ledge.receiveShadow = true;
                    building.add(ledge);
                }
            }
        }

        function addBuildingWindows(worldX, worldZ, width, depth, height) {
            const rows = THREE.MathUtils.clamp(Math.round(height / 5), 3, 18);

            const marginY = 2.2;
            const usableH = Math.max(1, height - marginY * 2);
            const stepY = usableH / rows;
            const windowH = Math.min(0.9, stepY * 0.45);

            const zOffset = (depth / 2) + 0.08;
            const xOffset = (width / 2) + 0.08;

            function addFace(span, rotY, dx, dz, axis) {
                const cols = THREE.MathUtils.clamp(Math.round(span / 2.6), 2, 7);
                const margin = Math.min(1.4, span * 0.16);
                const usable = Math.max(1, span - margin * 2);
                const step = usable / cols;
                const windowW = Math.min(1.25, step * 0.62);

                for (let r = 0; r < rows; r++) {
                    if (r % 2 === 1 && Math.random() < 0.55) continue;
                    const y = marginY + (r + 0.5) * stepY;
                    if (y > height - 1) continue;

                    for (let c = 0; c < cols; c++) {
                        if ((c + r) % 3 === 0 && Math.random() < 0.35) continue;
                        if (windowInstanceCount >= maxWindowInstances) return;

                        const along = (-span / 2) + margin + (c + 0.5) * step;
                        const localX = axis === 'x' ? along : 0;
                        const localZ = axis === 'z' ? along : 0;

                        windowDummy.position.set(worldX + dx + localX, y, worldZ + dz + localZ);
                        windowDummy.rotation.set(0, rotY, 0);
                        windowDummy.scale.set(windowW, Math.min(1.25, windowH * 1.18), 1);
                        windowDummy.updateMatrix();
                        windowMesh.setMatrixAt(windowInstanceCount, windowDummy.matrix);
                        windowInstanceCount++;
                    }
                }
            }

            addFace(width, 0, 0, zOffset, 'x');
            addFace(width, Math.PI, 0, -zOffset, 'x');
            addFace(depth, -Math.PI / 2, xOffset, 0, 'z');
            addFace(depth, Math.PI / 2, -xOffset, 0, 'z');
        }

        function addSkyscraperWindows(worldX, worldZ, width, depth, height) {
            const rows = THREE.MathUtils.clamp(Math.round(height / 3.6), 10, 44);
            const marginY = 2.6;
            const usableH = Math.max(1, height - marginY * 2);
            const stepY = usableH / rows;
            const windowH = Math.min(1.9, stepY * 0.85);

            const zOffset = (depth / 2) + 0.08;
            const xOffset = (width / 2) + 0.08;

            function addFace(span, rotY, dx, dz, axis, stripeBias) {
                const cols = THREE.MathUtils.clamp(Math.round(span / 1.9), 6, 16);
                const margin = Math.min(1.2, span * 0.12);
                const usable = Math.max(1, span - margin * 2);
                const step = usable / cols;
                const windowW = Math.min(1.0, step * 0.72);

                const stripeEvery = cols > 10 ? 3 : 2;
                const stripeWidth = stripeBias ? 0.55 : 0.75;

                for (let r = 0; r < rows; r++) {
                    const y = marginY + (r + 0.5) * stepY;
                    if (y > height - 1) continue;

                    const isShadowBand = (r % 12 === 0) && Math.random() < 0.55;
                    for (let c = 0; c < cols; c++) {
                        if (skyscraperWindowInstanceCount >= maxSkyscraperWindowInstances) return;

                        if (isShadowBand && c % 2 === 1) continue;
                        if (Math.random() < 0.10) continue;

                        const along = (-span / 2) + margin + (c + 0.5) * step;
                        const localX = axis === 'x' ? along : 0;
                        const localZ = axis === 'z' ? along : 0;

                        const stripe = (c % stripeEvery) === 0;
                        const wScale = stripe ? (windowW * stripeWidth) : windowW;

                        skyscraperWindowDummy.position.set(worldX + dx + localX, y, worldZ + dz + localZ);
                        skyscraperWindowDummy.rotation.set(0, rotY, 0);
                        skyscraperWindowDummy.scale.set(wScale, windowH, 1);
                        skyscraperWindowDummy.updateMatrix();
                        skyscraperWindowMesh.setMatrixAt(skyscraperWindowInstanceCount, skyscraperWindowDummy.matrix);
                        skyscraperWindowInstanceCount++;
                    }
                }
            }

            addFace(width, 0, 0, zOffset, 'x', true);
            addFace(width, Math.PI, 0, -zOffset, 'x', false);
            addFace(depth, -Math.PI / 2, xOffset, 0, 'z', true);
            addFace(depth, Math.PI / 2, -xOffset, 0, 'z', false);
        }

        // --- SYSTEM LOGGER ---
        const Logger = {
            init: function() {
                // Intercept console methods
                const oldLog = console.log;
                const oldWarn = console.warn;
                const oldError = console.error;
                
                console.log = function(...args) {
                    oldLog.apply(console, args);
                    Logger.addEntry('info', args);
                };
                
                console.warn = function(...args) {
                    oldWarn.apply(console, args);
                    Logger.addEntry('warn', args);
                };
                
                console.error = function(...args) {
                    oldError.apply(console, args);
                    Logger.addEntry('error', args);
                };
                
                Logger.log("System initialized. Logger attached.");
            },
            
            log: function(msg) {
                console.log(msg); // Will trigger interceptor
            },
            
            addEntry: function(type, args) {
                const panel = document.getElementById('logs-content');
                if (!panel) return;
                
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                
                const now = new Date();
                const time = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
                
                // Convert args to string
                const message = args.map(arg => {
                    if (typeof arg === 'object') return JSON.stringify(arg);
                    return String(arg);
                }).join(' ');
                
                entry.innerHTML = `<span class="log-timestamp">[${time}]</span> ${message}`;
                
                panel.appendChild(entry);
                panel.scrollTop = panel.scrollHeight; // Auto scroll
            }
        };

        function toggleLogsPanel() {
            const panel = document.getElementById('logs-panel');
            const btn = document.getElementById('btn-logs');
            
            panel.classList.toggle('active');
            btn.classList.toggle('active');
        }

        // --- POPULATION STATS ---
        const populationState = { active: false, meshes: [] };

        function togglePopulationStats() {
            populationState.active = !populationState.active;
            const btn = document.getElementById('btn-pop');
            if (btn) btn.classList.toggle('active');

            if (populationState.active) {
                Logger.log("[SYSTEM] Visualizing population density metrics...");
                
                // If already generated, show them
                if (populationState.meshes.length > 0) {
                    populationState.meshes.forEach(m => m.visible = true);
                    return;
                }

                // Generate Meshes
                let count = 0;
                buildings.forEach(b => {
                    // Skip if building is not valid or doesn't have geometry
                    if (!b.geometry) return;

                    // 1. Ensure Population Data Exists
                    if (!b.userData.population) {
                        // Estimate based on volume/height
                        let h = 10;
                        if (b.geometry.parameters && b.geometry.parameters.height) {
                            h = b.geometry.parameters.height;
                        } else {
                            b.geometry.computeBoundingBox();
                            h = b.geometry.boundingBox.max.y - b.geometry.boundingBox.min.y;
                        }

                        // Base calc
                        let pop = Math.floor(h * 5 + Math.random() * 50);
                        
                        // Boost for special types
                        if (b.userData.type) {
                            if (b.userData.type.includes("Tower") || b.userData.type.includes("HQ")) pop *= 3;
                            if (b.userData.type.includes("Apartment")) pop *= 2;
                            if (b.userData.type.includes("Stadium")) pop = 8000 + Math.random() * 2000;
                            if (b.userData.type.includes("Supermarket")) pop = 300 + Math.random() * 100;
                            if (b.userData.type.includes("School")) pop = 800 + Math.random() * 200;
                            if (b.userData.type.includes("Hospital")) pop = 1200 + Math.random() * 300;
                        }
                        
                        b.userData.population = Math.floor(pop);
                    }

                    // 2. Create Visualization Bar
                    const pop = b.userData.population;
                    // Scale height: e.g. 100 people = 1 unit height
                    // Clamp min height to be visible
                    const barHeight = Math.max(2, pop / 40); 
                    
                    // Color gradient based on density? User asked for "red bar".
                    // Let's make it red, maybe darker red for denser? Or just standard red.
                    // User said "tall red block".
                    
                    const geo = new THREE.BoxGeometry(2, barHeight, 2);
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    const bar = new THREE.Mesh(geo, mat);

                    // 3. Position on Top
                    // Get world position of the building
                    const worldPos = new THREE.Vector3();
                    b.getWorldPosition(worldPos);
                    
                    // Calculate top Y
                    // Most buildings: Origin at bottom (y=0 relative to parent)
                    // But geometry translated up by h/2.
                    // So BoundingBox.max.y is height.
                    if (!b.geometry.boundingBox) b.geometry.computeBoundingBox();
                    const maxY = b.geometry.boundingBox.max.y;
                    
                    // Account for scaling if any (usually 1)
                    const finalH = maxY * b.scale.y;
                    
                    // Bar position: 
                    // X, Z = building center
                    // Y = building bottom (worldPos.y) + height (finalH) + barHeight/2 + gap
                    
                    bar.position.set(
                        worldPos.x, 
                        worldPos.y + finalH + barHeight/2 + 0.5, 
                        worldPos.z
                    );
                    
                    scene.add(bar);
                    populationState.meshes.push(bar);
                    count++;
                });
                
                Logger.log(`[STATS] Population data mapped for ${count} structures.`);

            } else {
                // Hide
                populationState.meshes.forEach(m => m.visible = false);
            }
        }

        // --- GLOBAL STATE ---
        // Store meshes by type so we can toggle them independently
        const greenState = {
            solar: { active: false, meshes: [], stats: { count: 0, energy: 0 } },
            garden: { active: false, meshes: [], stats: { count: 0, heat: 0 } },
            vertical: { active: false, meshes: [], stats: { count: 0, air: 0 } }
        };

        const energyState = {
            wind: { active: false, meshes: [], capacity: 0 },
            battery: { active: false, meshes: [], capacity: 0 }
        };

        // Fungsi pilih warna gedung acak dari palet
        function getRandomBuildingColor() {
            return config.buildingPalette[Math.floor(Math.random() * config.buildingPalette.length)];
        }

        const terrainBaseY = -15;

        function smoothstep(edge0, edge1, x) {
            const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
            return t * t * (3 - 2 * t);
        }

        function hash2D(ix, iz) {
            const s = Math.sin(ix * 127.1 + iz * 311.7) * 43758.5453123;
            return s - Math.floor(s);
        }

        function valueNoise2D(x, z) {
            const xi = Math.floor(x);
            const zi = Math.floor(z);
            const xf = x - xi;
            const zf = z - zi;

            const u = xf * xf * (3 - 2 * xf);
            const v = zf * zf * (3 - 2 * zf);

            const n00 = hash2D(xi, zi);
            const n10 = hash2D(xi + 1, zi);
            const n01 = hash2D(xi, zi + 1);
            const n11 = hash2D(xi + 1, zi + 1);

            const x1 = THREE.MathUtils.lerp(n00, n10, u);
            const x2 = THREE.MathUtils.lerp(n01, n11, u);
            return THREE.MathUtils.lerp(x1, x2, v) * 2 - 1;
        }

        function fbm2D(x, z) {
            let sum = 0;
            let amp = 1;
            let freq = 1;
            let norm = 0;
            for (let o = 0; o < 5; o++) {
                sum += valueNoise2D(x * freq, z * freq) * amp;
                norm += amp;
                amp *= 0.5;
                freq *= 2.0;
            }
            return sum / norm;
        }

        // --- NEW: Organic City Boundary Function ---
        function getCityBoundary(angle) {
            // Max radius based on grid size (e.g. 50 * 25 / 2 = 625)
            const maxRadius = (config.gridSize * config.cellSize) / 2;
            
            // Use unit circle coordinates for seamless noise
            const nx = Math.cos(angle);
            const nz = Math.sin(angle);
            
            // Perlin noise on the circle to create "blob" shape
            const noiseVal = fbm2D(nx * 1.5, nz * 1.5); 
            
            // Vary radius between ~50% and ~90% of max size
            const base = maxRadius * 0.7;
            const variation = maxRadius * 0.25;
            
            return base + noiseVal * variation;
        }

        function createSea() {
            const waterSize = config.terrainSize * config.waterSizeMultiplier;
            const seaGeo = new THREE.PlaneGeometry(waterSize, waterSize, 1, 1);
            const seaMat = new THREE.MeshStandardMaterial({
                color: 0x2a78c5,
                roughness: 0.12,
                metalness: 0.2,
                transparent: true,
                opacity: 0.95
            });
            const sea = new THREE.Mesh(seaGeo, seaMat);
            sea.rotation.x = -Math.PI / 2;
            sea.position.y = config.seaLevel;
            sea.receiveShadow = false;
            scene.add(sea);
        }

        // Function to create hilly terrain with trees
        function createHillyTerrain() {
            const terrainGeo = new THREE.PlaneGeometry(
                config.terrainSize,
                config.terrainSize,
                config.terrainSegments,
                config.terrainSegments
            );

            const vertices = terrainGeo.attributes.position.array;
            const colors = new Float32Array(terrainGeo.attributes.position.count * 3);

            const cityRadius = (config.gridSize * config.cellSize) / 2 + 100;
            const cityFadeEnd = cityRadius + 200; // Wider fade
            const islandRadius = 1500; // Fixed island radius
            const coastWidth = 600; // Wider coast
            const noiseScale = 0.0022; // Lower frequency for larger terrain

            function computeTerrainHeightLocal(x, z) {
                const distFromCenter = Math.sqrt(x * x + z * z);

                // --- OPTIMIZATION: Deep Ocean ---
                if (distFromCenter > 2400) return -50;

                // --- Shoreline Distortion ---
                const distortion = fbm2D(x * 0.0015, z * 0.0015) * 250;
                const distForIsland = distFromCenter + distortion;

                // --- Island Masking (Organic Shape) ---
                const angle = Math.atan2(z, x);
                const boundary = getCityBoundary(angle);
                const cityFadeEnd = boundary + 200; // Smooth transition
                
                const cityBlend = smoothstep(boundary, cityFadeEnd, distFromCenter);
                if (cityBlend <= 0.0001) return 0;

                const islandBlend = THREE.MathUtils.clamp((islandRadius - distForIsland) / coastWidth, 0, 1);
                const islandMask = smoothstep(0, 1, islandBlend);
                if (islandMask <= 0.0001) return -50;

                // --- Domain Warping (for more natural shapes) ---
                const warpFreq1 = 0.0015;
                const warpAmp1 = 250;
                const qx = x + fbm2D(x * warpFreq1, z * warpFreq1) * warpAmp1;
                const qz = z + fbm2D((x + 543.1) * warpFreq1, (z - 211.7) * warpFreq1) * warpAmp1;

                const warpFreq2 = 0.004;
                const warpAmp2 = 80;
                const rx = qx + fbm2D(qx * warpFreq2, qz * warpFreq2) * warpAmp2;
                const rz = qz + fbm2D((qx - 199.3) * warpFreq2, (qz + 437.9) * warpFreq2) * warpAmp2;

                // --- Base Noise Layers ---
                const n1 = fbm2D(rx * noiseScale, rz * noiseScale); // Base large features
                const n2 = fbm2D(rx * noiseScale * 3.1, rz * noiseScale * 3.1); // Medium details
                const n3 = fbm2D(rx * noiseScale * 8.7, rz * noiseScale * 8.7); // Fine details
                
                let baseTerrain = n1 * 0.6 + n2 * 0.25 + n3 * 0.15;

                // --- Ridge Generation ---
                const ridgeNoise = 1.0 - Math.abs(fbm2D(rx * noiseScale * 2.2, rz * noiseScale * 2.2));
                baseTerrain = THREE.MathUtils.lerp(baseTerrain, Math.max(baseTerrain, ridgeNoise), 0.4);
                baseTerrain += Math.pow(ridgeNoise, 3.0) * 0.3;

                // --- Mountain Range Definition ---
                // Reduce noise scale (0.3 -> 0.4) to make features smaller/tighter
                // Increase threshold (0.35 -> 0.45) to make mountains sparser
                const mountainNoise = (fbm2D(qx * noiseScale * 0.4, qz * noiseScale * 0.4) + 1) / 2;
                // Use distForIsland so mountains respect the irregular shoreline
                // Reduce outer limit (islandRadius - 400 -> islandRadius - 600) to keep mountains away from shore
                const mountainMask = smoothstep(cityFadeEnd + 300, islandRadius - 600, distForIsland) * smoothstep(0.45, 0.75, mountainNoise);
                
                // --- Final Height Calculation ---
                // Reduce mountain height multiplier (2.0 -> 1.5)
                const hills = baseTerrain * config.hillHeight * (1.0 + 1.5 * mountainMask);
                
                const islandLift = 30 * islandMask;
                const shoreDrop = -50 * Math.pow(1 - islandMask, 1.8);

                return (islandLift + hills * islandMask) * cityBlend + shoreDrop * cityBlend;
            }

            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                // Invert Z because PlaneGeometry creates Y from + to -, but World Z usually goes - to +.
                // Also terrain is rotated -90 deg X, so Local Y -> -World Z.
                // We want noise(x, z_world), so we pass -vertices[i+1].
                const z = -vertices[i + 1]; 
                const h = computeTerrainHeightLocal(x, z);
                vertices[i + 2] = h;

                const worldY = terrainBaseY + h;
                const aboveSea = worldY - config.seaLevel;

                const sand = new THREE.Color(0xdcc58a);
                const grass = new THREE.Color(0x4a752a); // Darker, more natural grass
                const darkGrass = new THREE.Color(0x385920);
                const rock = new THREE.Color(0x6a6259);
                const snow = new THREE.Color(0xf0f4f7);
                const abyss = new THREE.Color(0x1a1a2e); // Dark deep sea floor (matches bg)

                let c = grass.clone();
                if (aboveSea < -35) c = abyss.clone();
                else if (aboveSea < 1.5) c = sand.clone().lerp(abyss, smoothstep(1.5, -35, aboveSea));
                else if (aboveSea < 10) c = sand.clone().lerp(grass, smoothstep(1.5, 10, aboveSea));
                else if (aboveSea < 50) c = grass.clone().lerp(darkGrass, smoothstep(10, 50, aboveSea));
                else if (aboveSea < 100) c = darkGrass.clone().lerp(rock, smoothstep(50, 100, aboveSea));
                else if (aboveSea < 140) c = rock.clone();
                else c = rock.clone().lerp(snow, smoothstep(140, 180, aboveSea));

                const ci = (i / 3) * 3;
                colors[ci] = c.r;
                colors[ci + 1] = c.g;
                colors[ci + 2] = c.b;
            }

            terrainGeo.computeVertexNormals();
            terrainGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const terrainMat = new THREE.MeshStandardMaterial({
                roughness: 0.9,
                metalness: 0.0,
                vertexColors: true
            });

            const terrain = new THREE.Mesh(terrainGeo, terrainMat);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.y = terrainBaseY;
            terrain.receiveShadow = true;
            scene.add(terrain);
            // terrain.updateMatrixWorld(); // Ensure matrixWorld is up-to-date for raycasting

            // --- HELPER: Get exact mesh height (interpolation) ---
            // This prevents trees from floating or sinking due to low-poly mesh interpolation
            function getMeshHeight(x, z) {
                const segs = config.terrainSegments;
                const halfSize = config.terrainSize / 2;
                const segmentSize = config.terrainSize / segs;
                
                // Map x,z to grid coordinates
                // PlaneGeometry builds rows from top (+Y/Z) to bottom (-Y/Z)
                // and cols from left (-X) to right (+X).
                
                // Col (X): -halfSize -> 0, +halfSize -> segs
                let col = (x + halfSize) / segmentSize;
                // Row (Z): -halfSize (top) -> 0, +halfSize (bottom) -> segs
                // Since PlaneGeometry builds top-down (Local Y + to -), and Local Y = -World Z:
                // Row 0 corresponds to Local Y = +halfSize -> World Z = -halfSize.
                // Row N corresponds to Local Y = -halfSize -> World Z = +halfSize.
                // So row should increase as Z increases.
                let row = (z + halfSize) / segmentSize;
                
                // Integer parts
                let c0 = Math.floor(col);
                let r0 = Math.floor(row);
                
                // Clamp
                if (c0 < 0) c0 = 0; if (c0 >= segs) c0 = segs - 1;
                if (r0 < 0) r0 = 0; if (r0 >= segs) r0 = segs - 1;
                
                let c1 = c0 + 1;
                let r1 = r0 + 1;
                
                // Fractions
                let u = col - c0;
                let v = row - r0;
                u = Math.max(0, Math.min(1, u));
                v = Math.max(0, Math.min(1, v));
                
                // Indices in vertex array (Row-major: index = row * (segs+1) + col)
                const stride = 3;
                const rowStride = (segs + 1) * stride;
                
                const i00 = r0 * rowStride + c0 * stride + 2; // +2 for Z (height)
                const i10 = r0 * rowStride + c1 * stride + 2;
                const i01 = r1 * rowStride + c0 * stride + 2;
                const i11 = r1 * rowStride + c1 * stride + 2;
                
                // Bilinear Interpolation
                const h00 = vertices[i00];
                const h10 = vertices[i10];
                const h01 = vertices[i01];
                const h11 = vertices[i11];
                
                const hTop = h00 * (1 - u) + h10 * u;
                const hBot = h01 * (1 - u) + h11 * u;
                
                return hTop * (1 - v) + hBot * v;
            }

            // --- OPTIMIZED TREE PLACEMENT (No Raycaster) ---
            // Re-using the noise function is much faster than raycasting 3000+ times against high-poly terrain
            
            let treesPlaced = 0;
            let attempts = 0;
            const maxAttempts = config.terrainTreeCount * 3;

            while (treesPlaced < config.terrainTreeCount && attempts < maxAttempts) {
                attempts++;
                const angle = Math.random() * Math.PI * 2;
                const cityRadius = (config.gridSize * config.cellSize) / 2;
                const minDist = cityRadius + 150;
                // OPTIMIZATION: Restrict tree placement to the island radius.
                // Don't try to place trees in the deep ocean (it wastes attempts).
                const maxDist = 1500 - 100; 
                
                // Bias distribution slightly further out
                const dist = minDist + Math.pow(Math.random(), 1.2) * (maxDist - minDist);

                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                // Directly calculate height
                const h = computeTerrainHeightLocal(x, z);
                const worldY = terrainBaseY + h;
                const aboveSea = worldY - config.seaLevel;

                // 1. Avoid water (with buffer)
                if (aboveSea < 4) {
                    continue;
                }

                // 2. Avoid steep slopes
                // Calculate gradient (slope) using finite difference
                const delta = 1.0;
                const hRight = computeTerrainHeightLocal(x + delta, z);
                const hForward = computeTerrainHeightLocal(x, z + delta);
                
                // Approximate normal
                const slopeX = (hRight - h) / delta;
                const slopeZ = (hForward - h) / delta;
                
                // Magnitude of the slope vector (approximate)
                const slopeMagnitude = Math.sqrt(slopeX*slopeX + slopeZ*slopeZ);

                if (slopeMagnitude > 0.6) { // Threshold for steepness
                    continue;
                }

                // FIX: Use interpolated mesh height for visual placement
                const meshH = getMeshHeight(x, z);
                const visualWorldY = terrainBaseY + meshH;

                createTerrainTree(x, z, visualWorldY);
                treesPlaced++;
            }

            // --- WINDMILL PLACEMENT ---
            // Place windmills on high ground/ridges
            let windmillsPlaced = 0;
            let wmAttempts = 0;
            const maxWmAttempts = 200;
            const windmillCount = 8;
            
            while (windmillsPlaced < windmillCount && wmAttempts < maxWmAttempts) {
                wmAttempts++;
                const angle = Math.random() * Math.PI * 2;
                const cityRadius = (config.gridSize * config.cellSize) / 2;
                const minDist = cityRadius + 300;
                const maxDist = 1500 - 200;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                const h = computeTerrainHeightLocal(x, z);
                const worldY = terrainBaseY + h;
                const aboveSea = worldY - config.seaLevel;

                // Needs to be reasonably high but not too steep
                if (aboveSea < 40) continue;

                // Check slope - flat enough for a building
                const delta = 2.0;
                const hRight = computeTerrainHeightLocal(x + delta, z);
                const hForward = computeTerrainHeightLocal(x, z + delta);
                const slopeX = (hRight - h) / delta;
                const slopeZ = (hForward - h) / delta;
                const slopeMagnitude = Math.sqrt(slopeX*slopeX + slopeZ*slopeZ);

                if (slopeMagnitude > 0.4) continue;

                const meshH = getMeshHeight(x, z);
                const visualWorldY = terrainBaseY + meshH;
                
                createWindmill(x, z, visualWorldY);
                windmillsPlaced++;
            }

            // --- ROCK PLACEMENT ---
            // Scatter rocks everywhere
            let rocksPlaced = 0;
            let rockAttempts = 0;
            const rockCount = 800;
            const maxRockAttempts = rockCount * 2;

            while (rocksPlaced < rockCount && rockAttempts < maxRockAttempts) {
                rockAttempts++;
                const angle = Math.random() * Math.PI * 2;
                const cityRadius = (config.gridSize * config.cellSize) / 2;
                const minDist = cityRadius + 100;
                const maxDist = 1500 - 50;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                const h = computeTerrainHeightLocal(x, z);
                const worldY = terrainBaseY + h;
                const aboveSea = worldY - config.seaLevel;

                if (aboveSea < 2) continue; // Just above water line

                const meshH = getMeshHeight(x, z);
                const visualWorldY = terrainBaseY + meshH;
                
                createRock(x, z, visualWorldY);
                rocksPlaced++;
            }
        }
        
        const windmills = []; // Array to store windmills for animation

        function createWindmill(x, z, y) {
            const wmGroup = new THREE.Group();
            const scale = 1.2;

            // Tower
            const towerHeight = 15 * scale;
            const towerGeo = new THREE.CylinderGeometry(0.8 * scale, 1.8 * scale, towerHeight, 8);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const tower = new THREE.Mesh(towerGeo, towerMat);
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            wmGroup.add(tower);

            // Nacelle (Head)
            const nacelleGeo = new THREE.BoxGeometry(4 * scale, 2.5 * scale, 3 * scale);
            const nacelleMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const nacelle = new THREE.Mesh(nacelleGeo, nacelleMat);
            nacelle.position.y = towerHeight;
            wmGroup.add(nacelle);

            // Rotor Center
            const rotorGeo = new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 1 * scale, 16);
            rotorGeo.rotateX(Math.PI / 2);
            const rotorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const rotor = new THREE.Mesh(rotorGeo, rotorMat);
            rotor.position.set(0, towerHeight, 1.5 * scale);
            wmGroup.add(rotor);

            // Blades Group (Rotates)
            const bladesGroup = new THREE.Group();
            bladesGroup.position.set(0, towerHeight, 1.5 * scale);
            wmGroup.add(bladesGroup);

            const bladeLen = 12 * scale;
            const bladeW = 1.5 * scale;
            const bladeGeo = new THREE.BoxGeometry(bladeW, bladeLen, 0.2 * scale);
            // Offset blade so it rotates around one end
            bladeGeo.translate(0, bladeLen / 2, 0);
            
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            for (let i = 0; i < 3; i++) {
                const blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.rotation.z = i * (Math.PI * 2 / 3);
                blade.castShadow = true;
                bladesGroup.add(blade);
            }

            wmGroup.position.set(x, y, z);
            // Rotate randomly to face different directions
            wmGroup.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(wmGroup);
            
            // Store for animation
            windmills.push({
                mesh: bladesGroup,
                speed: 0.5 + Math.random() * 0.5 // Random rotation speed
            });
        }

        function createRock(x, z, y) {
            const size = 1 + Math.random() * 3;
            // Use low-poly geometries for rocks
            let geo;
            if (Math.random() > 0.5) {
                geo = new THREE.DodecahedronGeometry(size, 0);
            } else {
                geo = new THREE.IcosahedronGeometry(size, 0);
            }
            
            // Distort the rock
            geo.scale(
                1 + (Math.random() - 0.5) * 0.4, 
                0.6 + (Math.random() - 0.5) * 0.4, // Flatter
                1 + (Math.random() - 0.5) * 0.4
            );

            const mat = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0x7a7a7a : 0x5c5c5c,
                roughness: 0.9,
                flatShading: true
            });

            const rock = new THREE.Mesh(geo, mat);
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            // Embed slightly in ground
            rock.position.set(x, y + size * 0.3, z);
            rock.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            scene.add(rock);
        }

        function createTerrainTree(x, z, baseY) {
            const tree = new THREE.Group();
            const scale = 0.8 + Math.random() * 0.4; // Random size

            const trunkHeight = (6 + Math.random() * 4) * scale;
            const trunkRadius = (0.4 + Math.random() * 0.2) * scale;
            const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x5D4037,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            trunk.position.y = trunkHeight / 2;
            tree.add(trunk);

            const crownLevels = Math.floor(3 + Math.random() * 3);
            let levelY = trunkHeight;
            let currentRadius = (3 + Math.random() * 2) * scale;

            const crownColors = [0x285C2A, 0x3A7D44, 0x4F9D5A];
            const crownMat = new THREE.MeshStandardMaterial({
                color: crownColors[Math.floor(Math.random() * crownColors.length)],
                roughness: 0.8,
                flatShading: false // Smoother crowns
            });

            for (let i = 0; i < crownLevels; i++) {
                const levelHeight = (4 + Math.random() * 2) * scale;
                const levelRadius = currentRadius * (1 + (Math.random() - 0.5) * 0.2);
                const crownGeo = new THREE.IcosahedronGeometry(levelRadius, 0); // More natural shape than cone
                const crown = new THREE.Mesh(crownGeo, crownMat);
                crown.castShadow = true;
                crown.position.y = levelY + levelHeight * 0.3;
                
                // Stretch it vertically
                crown.scale.y = 0.6 + Math.random() * 0.4;
                crown.scale.x = 1.0 + (Math.random() - 0.5) * 0.2;
                crown.scale.z = 1.0 + (Math.random() - 0.5) * 0.2;

                tree.add(crown);

                levelY += levelHeight * 0.5;
                currentRadius *= 0.7;
            }

            tree.position.set(x, baseY, z);
            // Random rotation
            tree.rotation.y = Math.random() * Math.PI * 2;
            scene.add(tree);
            trees.push(tree);
        }

        // --- AIRPLANE SYSTEM ---
        const airplane = {
            group: null,
            propeller: null,
            path: null,
            progress: 0,
            speed: 0.0005 // Increased speed
        };

        function createAirplane() {
             const planeGroup = new THREE.Group();

            // Colors
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
            const redMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.4 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 });

            // 1. Fuselage
            const fuselage = new THREE.Group();
            
            // Main body cylinder (Length 5)
            const fuseCylGeo = new THREE.CylinderGeometry(1.2, 1.2, 5, 8);
            const fuseCyl = new THREE.Mesh(fuseCylGeo, whiteMat);
            // Default cylinder is Y-up. Rotate X 90 to point Z.
            fuseCyl.rotation.x = Math.PI / 2;
            fuselage.add(fuseCyl);

            // Nose (Front is +Z)
            const fuseNoseGeo = new THREE.SphereGeometry(1.2, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
            const fuseNose = new THREE.Mesh(fuseNoseGeo, whiteMat);
            fuseNose.rotation.x = Math.PI / 2;
            fuseNose.position.z = 2.5; // Front
            fuselage.add(fuseNose);

            // Tail Cone (Back is -Z)
            const fuseTailGeo = new THREE.SphereGeometry(1.2, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
            const fuseTail = new THREE.Mesh(fuseTailGeo, whiteMat);
            fuseTail.rotation.x = -Math.PI / 2; // Point back
            fuseTail.position.z = -2.5;
            fuselage.add(fuseTail);

            planeGroup.add(fuselage);

            // Cockpit
            const cockpit = new THREE.Group();
            
            // Cockpit body
            const cockCylGeo = new THREE.CylinderGeometry(1, 1, 2, 8);
            const cockCyl = new THREE.Mesh(cockCylGeo, darkMat);
            cockCyl.rotation.x = Math.PI / 2;
            cockpit.add(cockCyl);

            // Cockpit ends
            const cockCapGeo = new THREE.SphereGeometry(1, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
            
            const cockFront = new THREE.Mesh(cockCapGeo, darkMat);
            cockFront.rotation.x = Math.PI / 2;
            cockFront.position.z = 1;
            cockpit.add(cockFront);

            const cockBack = new THREE.Mesh(cockCapGeo, darkMat);
            cockBack.rotation.x = -Math.PI / 2;
            cockBack.position.z = -1;
            cockpit.add(cockBack);

            cockpit.position.set(0, 0.8, 0.5); // Up and slightly forward
            cockpit.scale.set(0.8, 0.6, 1);
            planeGroup.add(cockpit);

            // 2. Main Wings (Wide X, Short Z)
            const wingGeo = new THREE.BoxGeometry(10, 0.2, 2);
            const wing = new THREE.Mesh(wingGeo, redMat);
            wing.position.set(0, 0, 0.5);
            planeGroup.add(wing);

            // 3. Tail (Vertical Stabilizer)
            const tailGeo = new THREE.BoxGeometry(0.2, 2.5, 2);
            const tail = new THREE.Mesh(tailGeo, redMat);
            tail.position.set(0, 1.2, -2.5);
            planeGroup.add(tail);

            // Horizontal Stabilizer
            const hStabGeo = new THREE.BoxGeometry(4, 0.2, 1.5);
            const hStab = new THREE.Mesh(hStabGeo, redMat);
            hStab.position.set(0, 0.5, -2.5);
            planeGroup.add(hStab);

            // 4. Propeller
            const propellerGroup = new THREE.Group();
            const propGeo = new THREE.BoxGeometry(0.2, 2.8, 0.2);
            const prop1 = new THREE.Mesh(propGeo, darkMat);
            const prop2 = new THREE.Mesh(propGeo, darkMat);
            prop2.rotation.z = Math.PI / 2; // Cross shape
            propellerGroup.add(prop1);
            propellerGroup.add(prop2);

            propellerGroup.position.set(0, 0, 3.8); // At the nose tip
            planeGroup.add(propellerGroup);

            // Add Lights to plane
            const planeLight = new THREE.PointLight(0xff0000, 2, 100);
            planeLight.position.set(0, 2, 0);
            planeGroup.add(planeLight);

            // Scale up
            planeGroup.scale.set(3, 3, 3);

            // Setup State
            airplane.group = planeGroup;
            airplane.propeller = propellerGroup;
            
            // Create circular path above city
            const curve = new THREE.EllipseCurve(
                0, 0,             // ax, aY
                300, 300,         // xRadius, yRadius
                0, 2 * Math.PI,   // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );
            // Convert to 3D path (x, z)
            const points = curve.getPoints(300); // Smoother path
            airplane.path = points.map(p => new THREE.Vector3(p.x, 120, p.y)); 

            scene.add(planeGroup);
        }

        function updateAirplane() {
             if (!airplane.group || !airplane.path) return;

            // Move Propeller (Rotate Z axis)
            if (airplane.propeller) {
                airplane.propeller.rotation.z += 0.8;
            }

            // Move along path
            airplane.progress += airplane.speed;
            if (airplane.progress > 1) airplane.progress = 0;

            // Get position on curve
            const index = Math.floor(airplane.progress * (airplane.path.length - 1));
            const nextIndex = (index + 1) % airplane.path.length;
            
            const currentPos = airplane.path[index];
            const nextPos = airplane.path[nextIndex];

            // Lerp for smooth movement
            const alpha = (airplane.progress * (airplane.path.length - 1)) - index;
            const pos = new THREE.Vector3().lerpVectors(currentPos, nextPos, alpha);
            
            airplane.group.position.copy(pos);
            
            // Look at next point (Forward is +Z)
            airplane.group.lookAt(nextPos);
            
            // Apply banking (Roll)
            // Since lookAt resets the local rotation matrix, we can apply roll after.
            // Rotating around Z-axis (Local)
            airplane.group.rotateZ(-0.5); // Bank left for CCW turn
        }

        function createStadium(x, z) {
            const cellSize = config.cellSize;
            // Center of the 2x2 block
            const centerX = x + cellSize / 2;
            const centerZ = z + cellSize / 2;

            const stadiumGroup = new THREE.Group();
            stadiumGroup.position.set(centerX, 0, centerZ);

            const stadiumData = {
                id: `Stadium-${x}-${z}`,
                type: "City Arena",
                pollution: 60,
                energy: 200,
                traffic: 250,
                originalColor: 0x95a5a6
            };

            // 1. Stands (Oval simulated by scaling a Cylinder or Torus)
            // Using a thick tube for stands
            const standRadius = 14;
            const standTube = 4;
            const standGeo = new THREE.TorusGeometry(standRadius, standTube, 16, 40);
            const standMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.8 });
            
            const stands = new THREE.Mesh(standGeo, standMat);
            stands.rotation.x = -Math.PI / 2;
            stands.scale.set(1.5, 1, 1.2); // Oval shape (Rotated: Wide X)
            stands.position.y = 2; // Lift up slightly
            stands.castShadow = true;
            stands.receiveShadow = true;
            stands.userData = stadiumData;
            stadiumGroup.add(stands);
            buildings.push(stands);

            // 2. Field (Green Pitch)
            // Rotated dimensions: Wide X, Short Z
            const fieldW = 32;
            const fieldD = 20;
            const fieldGeo = new THREE.PlaneGeometry(fieldW, fieldD);
            const fieldMat = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1 });
            const field = new THREE.Mesh(fieldGeo, fieldMat);
            field.rotation.x = -Math.PI / 2;
            field.position.y = 0.2;
            field.receiveShadow = true;
            stadiumGroup.add(field);

            // Field markings
            const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const centerCircle = new THREE.Mesh(new THREE.RingGeometry(3, 3.2, 32), markMat);
            centerCircle.rotation.x = -Math.PI / 2;
            centerCircle.position.y = 0.25;
            stadiumGroup.add(centerCircle);

            // Midline now spans the depth (Z axis)
            const midLine = new THREE.Mesh(new THREE.PlaneGeometry(0.2, fieldD), markMat);
            midLine.rotation.x = -Math.PI / 2;
            midLine.position.y = 0.25;
            stadiumGroup.add(midLine);

            // 3. Floodlights
            const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 18);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });
            const lightGeo = new THREE.BoxGeometry(2, 2, 0.5);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2 });

            // Rotated positions
            const positions = [
                { x: -16, z: -12 }, { x: 16, z: -12 },
                { x: -16, z: 12 }, { x: 16, z: 12 }
            ];

            positions.forEach(pos => {
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(pos.x, 9, pos.z);
                pole.castShadow = true;
                stadiumGroup.add(pole);

                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(pos.x, 17, pos.z);
                light.lookAt(0, 0, 0); // Point to center
                stadiumGroup.add(light);
            });

            // 4. Roof Canopy (Partial Torus or Ring)
            const roofGeo = new THREE.TorusGeometry(standRadius + 2, 2, 8, 40, Math.PI * 2);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1, transparent: true, opacity: 0.9 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.rotation.x = -Math.PI / 2;
            roof.scale.set(1.5, 1, 1.2); // Rotated
            roof.position.y = 8;
            roof.castShadow = true;
            stadiumGroup.add(roof);

            scene.add(stadiumGroup);
        }

        function createSupermarket(x, z) {
            const cellSize = config.cellSize;
            // Center of the 2x2 block
            const centerX = x + cellSize / 2;
            const centerZ = z + cellSize / 2;

            const marketGroup = new THREE.Group();
            marketGroup.position.set(centerX, 0, centerZ);

            const marketData = {
                id: `Supermarket-${x}-${z}`,
                type: "Mega Supermarket",
                pollution: 40,
                energy: 120,
                traffic: 150,
                originalColor: 0x3498db
            };

            // 1. Main Building Structure
            const buildW = 24;
            const buildD = 16;
            const buildH = 9;
            const buildGeo = new THREE.BoxGeometry(buildW, buildH, buildD);
            buildGeo.translate(0, buildH / 2, 0);
            
            const matWall = new THREE.MeshStandardMaterial({ color: 0xecf0f1, roughness: 0.6 });
            const building = new THREE.Mesh(buildGeo, matWall);
            building.position.set(0, 0, -6); // Shift to back
            building.castShadow = true;
            building.receiveShadow = true;
            building.userData = marketData;
            marketGroup.add(building);
            buildings.push(building);

            // 2. Entrance / Glass Front
            const glassGeo = new THREE.BoxGeometry(12, 5, 1);
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0x88ccff, 
                metalness: 0.9, 
                roughness: 0.1, 
                transparent: true, 
                opacity: 0.6 
            });
            const entrance = new THREE.Mesh(glassGeo, glassMat);
            entrance.position.set(0, 2.5, -6 + buildD/2 + 0.1);
            marketGroup.add(entrance);

            // Canopy over entrance
            const canopyGeo = new THREE.BoxGeometry(14, 0.5, 4);
            const canopyMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c }); // Red canopy
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.set(0, 5.5, -6 + buildD/2 + 2);
            canopy.castShadow = true;
            marketGroup.add(canopy);

            // 3. Signage "MARKET" (Simulated with blocks)
            const signBoardGeo = new THREE.BoxGeometry(10, 2, 0.5);
            const signBoardMat = new THREE.MeshBasicMaterial({ color: 0x2980b9 });
            const signBoard = new THREE.Mesh(signBoardGeo, signBoardMat);
            signBoard.position.set(0, buildH - 2, -6 + buildD/2 + 0.3);
            marketGroup.add(signBoard);

            // 4. Parking Lot (Asphalt with lines)
            const lotW = 28;
            const lotD = 12;
            const lotGeo = new THREE.PlaneGeometry(lotW, lotD);
            const lotMat = new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.9 });
            const lot = new THREE.Mesh(lotGeo, lotMat);
            lot.rotation.x = -Math.PI / 2;
            lot.position.set(0, 0.1, 8); // Front area
            lot.receiveShadow = true;
            marketGroup.add(lot);

            // Parking Lines
            const lineGeo = new THREE.PlaneGeometry(0.2, 5);
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = -4; i <= 4; i++) {
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(i * 3, 0.12, 8);
                marketGroup.add(line);
            }

            // 5. Rooftop Details (AC Units)
            for (let i = 0; i < 3; i++) {
                const acGeo = new THREE.BoxGeometry(2, 1.5, 2);
                const acMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
                const ac = new THREE.Mesh(acGeo, acMat);
                ac.position.set((i - 1) * 6, buildH + 0.75, -6);
                ac.castShadow = true;
                marketGroup.add(ac);
            }

            scene.add(marketGroup);
        }

        // Fungsi Membuat Rumah Sakit (Custom Model)
        function createHospital(x, z) {
            const baseW = 12;
            const baseD = 6;
            const height = 28;
            
            // 1. Main Tower (Vertical Block)
            const towerGeo = new THREE.BoxGeometry(8, height, 8);
            towerGeo.translate(0, height/2, 0);
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const mainMesh = new THREE.Mesh(towerGeo, matWhite);
            mainMesh.position.set(x, 0, z);
            mainMesh.castShadow = true;
            mainMesh.receiveShadow = true;
            
            const hospitalData = { 
                id: 'Hospital-' + x + '-' + z,
                type: 'General Hospital',
                pollution: 35,
                energy: 85,
                traffic: 90,
                originalColor: 0xffffff
            };
            mainMesh.userData = hospitalData;

            // 2. Base Podium / Wings (Horizontal Block)
            const wingH = 10;
            const wingGeo = new THREE.BoxGeometry(14, wingH, 10);
            wingGeo.translate(0, wingH/2, 0); // Center at bottom
            const wingMesh = new THREE.Mesh(wingGeo, matWhite);
            wingMesh.castShadow = true;
            wingMesh.receiveShadow = true;
            mainMesh.add(wingMesh); // Attach to main

            // 3. Helipad on Roof
            const padGeo = new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32);
            const padMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const pad = new THREE.Mesh(padGeo, padMat);
            pad.position.y = height;
            mainMesh.add(pad);

            // 'H' Symbol
            const hMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const h1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 4), hMat);
            const h2 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 4), hMat);
            const h3 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.8), hMat);
            h1.position.set(-1.2, 0.1, 0);
            h2.position.set(1.2, 0.1, 0);
            h3.position.set(0, 0.1, 0);
            pad.add(h1); pad.add(h2); pad.add(h3);

            // 4. Red Cross Sign (Floating at front)
            const crossGroup = new THREE.Group();
            const crossMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const vBar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 4, 0.5), crossMat);
            const hBar = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 0.5), crossMat);
            crossGroup.add(vBar);
            crossGroup.add(hBar);
            crossGroup.position.set(0, height - 6, 4.2); // Front of tower
            mainMesh.add(crossGroup);

            // 5. Glass Entrance
            const glassGeo = new THREE.BoxGeometry(5, 3, 2);
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.7 });
            const entrance = new THREE.Mesh(glassGeo, glassMat);
            entrance.position.set(0, 1.5, 5.2);
            mainMesh.add(entrance);

            // Windows
            addBuildingWindows(x, z, 8, 8, height); // Tower windows
            // Offset windows for wings is tricky with current helper, so we skip or approximate
            // We can call helper with offset positions for wings
            // Wing is centered at x,z.
            addBuildingWindows(x, z, 14, 10, wingH); 

            scene.add(mainMesh);
            buildings.push(mainMesh);
        }

        // Fungsi Membuat Kantor Polisi (Sleek & Simplicity, tanpa huruf)
        function createPoliceDepartment(x, z) {
            // Dimensi dasar
            const baseW = 12;
            const baseD = 8;
            const height = 24;
            
            // 1. Menara Utama (bersih, modern)
            const towerGeo = new THREE.BoxGeometry(baseW, height, baseD);
            towerGeo.translate(0, height / 2, 0);
            const matDark = new THREE.MeshStandardMaterial({ color: 0x1f2a44, roughness: 0.35, metalness: 0.2 });
            const tower = new THREE.Mesh(towerGeo, matDark);
            tower.position.set(x, 0, z);
            tower.castShadow = true;
            tower.receiveShadow = true;
            
            const policeData = {
                id: 'Police-' + x + '-' + z,
                type: 'Police Department',
                pollution: 18,
                energy: 65,
                traffic: 55,
                originalColor: 0x1f2a44
            };
            tower.userData = policeData;
            
            // 2. Podium Bersih dengan aksen biru (tanpa teks)
            const podiumH = 10;
            const podiumGeo = new THREE.BoxGeometry(baseW + 6, podiumH, baseD + 4);
            podiumGeo.translate(0, podiumH / 2, 0);
            const matPodium = new THREE.MeshStandardMaterial({ color: 0x26324d, roughness: 0.6 });
            const podium = new THREE.Mesh(podiumGeo, matPodium);
            podium.castShadow = true;
            podium.receiveShadow = true;
            tower.add(podium);
            
            // 3. Aksen pita biru horizontal sebagai identitas
            const bandGeo = new THREE.BoxGeometry(baseW + 6.2, 0.6, 0.6);
            const bandMat = new THREE.MeshStandardMaterial({ color: 0x2b6eff, emissive: 0x2249aa, emissiveIntensity: 0.45 });
            const bandFront = new THREE.Mesh(bandGeo, bandMat);
            bandFront.position.set(0, podiumH * 0.75, (baseD + 4) / 2 + 0.05);
            podium.add(bandFront);
            const bandBack = bandFront.clone();
            bandBack.position.z = -((baseD + 4) / 2 + 0.05);
            podium.add(bandBack);
            
            // 4. Lampu rotator rooftop (dua warna, tanpa teks)
            const barGeo = new THREE.CylinderGeometry(0.6, 0.6, baseW * 0.8, 16);
            barGeo.rotateZ(Math.PI / 2);
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff3050, emissive: 0xff3050, emissiveIntensity: 1.0 });
            const matBlue = new THREE.MeshStandardMaterial({ color: 0x2b6eff, emissive: 0x2b6eff, emissiveIntensity: 1.0 });
            const lightBarGroup = new THREE.Group();
            const leftBar = new THREE.Mesh(barGeo, matRed);
            const rightBar = new THREE.Mesh(barGeo, matBlue);
            leftBar.scale.set(0.35, 1, 1);
            rightBar.scale.set(0.35, 1, 1);
            leftBar.position.set(-2.2, height, 0);
            rightBar.position.set(2.2, height, 0);
            lightBarGroup.add(leftBar);
            lightBarGroup.add(rightBar);
            tower.add(lightBarGroup);
            
            // 5. Emblem tameng sederhana di fasad depan (tanpa teks)
            const shield = new THREE.Group();
            const shieldBase = new THREE.Mesh(
                new THREE.ConeGeometry(1.6, 2.8, 6),
                new THREE.MeshStandardMaterial({ color: 0x2b6eff, metalness: 0.6, roughness: 0.3 })
            );
            shieldBase.rotation.x = Math.PI; // arah ke bawah
            shieldBase.position.set(0, height * 0.55, (baseD / 2) + 0.2);
            const shieldCap = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 1.0, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x8fb7ff, metalness: 0.4, roughness: 0.4 })
            );
            shieldCap.position.set(0, height * 0.62, (baseD / 2) + 0.22);
            shield.add(shieldBase);
            shield.add(shieldCap);
            tower.add(shield);
            
            // Jendela
            addBuildingWindows(x, z, baseW, baseD, height);
            addRooftopDetails(tower, baseW, baseD, height);
            addFacadeDetails(tower, baseW, baseD, height, 'standard', false);
            
            scene.add(tower);
            buildings.push(tower);
            policeStations.push(tower);
        }

        // Fungsi Membuat Sekolah (Custom Model 2x2 Large)
        function createSchool(x, z) {
            // Because it is 2x2, the center is offset from the top-left anchor (x,z)
            // x, z is the center of the top-left cell.
            // We want the school to cover (x,z), (x+1,z), (x,z+1), (x+1,z+1)
            // The center of this 2x2 area is:
            const cellSize = config.cellSize;
            const centerX = x + cellSize / 2;
            const centerZ = z + cellSize / 2;

            const height = 14;
            
            // Group for the whole school complex
            const schoolGroup = new THREE.Group();
            schoolGroup.position.set(centerX, 0, centerZ);

            // Common UserData for the school
            const schoolData = {
                id: `School-${x}-${z}`,
                type: "Public High School",
                pollution: 15,
                energy: 60,
                traffic: 85,
                originalColor: 0xd35400
            };

            // 1. Main Building (U-Shape)
            const mainW = 16; 
            const mainD = 10;
            const mainGeo = new THREE.BoxGeometry(mainW, height, mainD);
            mainGeo.translate(0, height/2, -8); // Shift back
            const matBrick = new THREE.MeshStandardMaterial({ color: 0xd35400, roughness: 0.8 });
            const mainMesh = new THREE.Mesh(mainGeo, matBrick);
            mainMesh.castShadow = true;
            mainMesh.receiveShadow = true;
            mainMesh.userData = schoolData;
            schoolGroup.add(mainMesh);
            buildings.push(mainMesh);

            // Wings
            const wingW = 6;
            const wingH = 10;
            const wingD = 16;
            const wingGeo = new THREE.BoxGeometry(wingW, wingH, wingD);
            wingGeo.translate(0, wingH/2, 0);
            
            const leftWing = new THREE.Mesh(wingGeo, matBrick);
            leftWing.position.set(-8, 0, -4);
            leftWing.castShadow = true;
            leftWing.receiveShadow = true;
            leftWing.userData = schoolData;
            schoolGroup.add(leftWing);
            buildings.push(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, matBrick);
            rightWing.position.set(8, 0, -4);
            rightWing.castShadow = true;
            rightWing.receiveShadow = true;
            rightWing.userData = schoolData;
            schoolGroup.add(rightWing);
            buildings.push(rightWing);

            // 2. Football Field (Green)
            // Placed in front of the building
            const fieldW = 18;
            const fieldL = 26;
            const fieldGeo = new THREE.PlaneGeometry(fieldW, fieldL);
            const fieldMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1.0 });
            const field = new THREE.Mesh(fieldGeo, fieldMat);
            field.rotation.x = -Math.PI / 2;
            field.position.set(0, 0.1, 10); // Front area
            field.receiveShadow = true;
            schoolGroup.add(field);

            // Field Lines (White)
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const border = new THREE.Mesh(new THREE.PlaneGeometry(fieldW, 0.5), lineMat);
            border.rotation.x = -Math.PI / 2;
            border.position.set(0, 0.12, 10); // Center line
            schoolGroup.add(border);
            
            const goalGeo = new THREE.BoxGeometry(6, 3, 1);
            const goalMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            
            const goal1 = new THREE.Mesh(goalGeo, goalMat);
            goal1.position.set(0, 1.5, 10 - fieldL/2 + 0.5);
            schoolGroup.add(goal1);

            const goal2 = new THREE.Mesh(goalGeo, goalMat);
            goal2.position.set(0, 1.5, 10 + fieldL/2 - 0.5);
            schoolGroup.add(goal2);

            // 3. Clock Tower
            const clockTowerH = 8;
            const clockTowerGeo = new THREE.BoxGeometry(5, clockTowerH, 5);
            clockTowerGeo.translate(0, clockTowerH/2, 0);
            const clockTower = new THREE.Mesh(clockTowerGeo, matBrick);
            clockTower.position.set(0, height, -8);
            clockTower.userData = schoolData;
            schoolGroup.add(clockTower);
            buildings.push(clockTower);
            
            const roofGeo = new THREE.ConeGeometry(4, 4, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.set(0, height + clockTowerH + 2, -8);
            roof.rotation.y = Math.PI/4;
            schoolGroup.add(roof);

            // Windows Logic (Simplified for Group)
            // Add windows relative to group center is hard with current helper function.
            // We'll skip complex windows for now or add simple blocks.
            
            scene.add(schoolGroup);
        }

        // FUNGSI UTAMA MEMBUAT KOTA
        function createCity() {
            const offset = (config.gridSize * config.cellSize) / 2;

            createSea();
            createHillyTerrain();
            createAirplane(); // Added per user request
            
            // 1. Setup Base Ground
            const cityGroundSize = (config.gridSize * config.cellSize) + 120;
            const planeGeo = new THREE.PlaneGeometry(cityGroundSize, cityGroundSize);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x254b2a, roughness: 0.95 });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            const map = Array(config.gridSize).fill().map(() => Array(config.gridSize).fill(0));
            cityRoadMap = map; // This will be filled during city generation and used for car navigation
            const center = Math.floor(config.gridSize / 2);
            
            // Check if grid point is within the organic city boundary
            const isInsideCity = (x, z) => {
                const wx = (x * config.cellSize) - offset;
                const wz = (z * config.cellSize) - offset;
                const dist = Math.sqrt(wx*wx + wz*wz);
                const angle = Math.atan2(wz, wx);
                const boundary = getCityBoundary(angle);
                return dist < boundary - 20; // Buffer to keep roads inside
            };

            const isValid = (x, z) => {
                if (x < 1 || x >= config.gridSize - 1 || z < 1 || z >= config.gridSize - 1) return false;
                return isInsideCity(x, z);
            };

            let roadSources = [];

            // A. Create the "Skeleton" (Single Width Cross) - Tetap ada
            for (let i = 1; i < config.gridSize - 1; i++) {
                if (isInsideCity(i, center)) {
                    map[i][center] = 1;
                    roadSources.push({ x: i, z: center });
                }
                if (isInsideCity(center, i)) {
                    map[center][i] = 1;
                    roadSources.push({ x: center, z: i });
                }
            }
            // B. Grow Branches Algorithm
            const totalBranches = 100; // How many times we try to grow a street

            for (let i = 0; i < totalBranches; i++) {
                // 1. Pick a random existing road to branch FROM
                if (roadSources.length === 0) break;
                const source = roadSources[Math.floor(Math.random() * roadSources.length)];

                // 2. Determine Perpendicular Direction
                // Check neighbors to see which way the source road goes
                const isHoriz = (isValid(source.x + 1, source.z) && map[source.x + 1][source.z] === 1) ||
                    (isValid(source.x - 1, source.z) && map[source.x - 1][source.z] === 1);

                // If source is horizontal, grow vertical (Z). If source is vertical, grow horizontal (X).
                // Randomize direction (positive or negative)
                const growDir = Math.random() > 0.5 ? 1 : -1;
                const dx = isHoriz ? 0 : growDir;
                const dz = isHoriz ? growDir : 0;

                // 3. Raycast / Draw the new street
                const streetLength = 4 + Math.floor(Math.random() * 10); // Random length 4-14 blocks
                let successfullyAdded = false;

                for (let len = 1; len <= streetLength; len++) {
                    const nx = source.x + (dx * len);
                    const nz = source.z + (dz * len);

                    // Stop if we hit bounds
                    if (!isValid(nx, nz)) break;

                    // Stop if we hit another existing road (don't overwrite, just connect and stop)
                    if (map[nx][nz] === 1) {
                        break;
                    }

                    // Build the road
                    map[nx][nz] = 1;

                    // Add this new spot to sources so we can branch off it later!
                    roadSources.push({ x: nx, z: nz });
                    successfullyAdded = true;
                }
            }

            const spacing = 5;
            for (let i = 4; i < config.gridSize - 4; i += spacing) {
                if (Math.random() < 0.65) {
                    for (let z = 2; z < config.gridSize - 2; z++) {
                        if (isInsideCity(i, z)) {
                            map[i][z] = 1;
                            if (z % 4 === 0) roadSources.push({ x: i, z });
                        }
                    }
                }
                if (Math.random() < 0.65) {
                    for (let x = 2; x < config.gridSize - 2; x++) {
                        if (isInsideCity(x, i)) {
                            map[x][i] = 1;
                            if (x % 4 === 0) roadSources.push({ x, z: i });
                        }
                    }
                }
            }

            // --- STEP 2: IDENTIFY SPECIAL BUILDING SPOTS ---
            
            // 2A. Find 2x2 Spots for Schools
            const validLargeSpots = [];
            for (let x = 0; x < config.gridSize - 1; x++) {
                for (let z = 0; z < config.gridSize - 1; z++) {
                    // Check 2x2 block
                    if (map[x][z] === 0 && map[x+1][z] === 0 && map[x][z+1] === 0 && map[x+1][z+1] === 0) {
                        if (isInsideCity(x, z) && isInsideCity(x+1, z+1)) {
                            validLargeSpots.push({x, z});
                        }
                    }
                }
            }
            
            // 2B. Find 1x1 Spots for Hospitals
            const validSpots = [];
            for (let x = 0; x < config.gridSize; x++) {
                for (let z = 0; z < config.gridSize; z++) {
                     if (map[x][z] === 0 && isInsideCity(x, z)) {
                         validSpots.push({x, z});
                     }
                }
            }
            
            // Shuffle
            const shuffle = (arr) => {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            };
            shuffle(validLargeSpots);
            shuffle(validSpots);
            
            const specialMap = {};
            
            // Assign Schools (2), Supermarkets (2), and Stadium (1)
            // Mark occupied spots to avoid overlap
            const occupied = new Set();
            let schoolCount = 0;
            let supermarketCount = 0;
            let stadiumCount = 0;
            
            for (const spot of validLargeSpots) {
                if (schoolCount >= 2 && supermarketCount >= 2 && stadiumCount >= 1) break;
                
                const k1 = `${spot.x},${spot.z}`;
                const k2 = `${spot.x+1},${spot.z}`;
                const k3 = `${spot.x},${spot.z+1}`;
                const k4 = `${spot.x+1},${spot.z+1}`;
                
                if (!occupied.has(k1) && !occupied.has(k2) && !occupied.has(k3) && !occupied.has(k4)) {
                    if (stadiumCount < 1) {
                        // Check surrounding buffer for stadium (it needs more space)
                        // We check 1 cell border around the 2x2 block
                        let bufferClear = true;
                        const bufferCells = [];
                        for(let bx = spot.x - 1; bx <= spot.x + 2; bx++) {
                            for(let bz = spot.z - 1; bz <= spot.z + 2; bz++) {
                                if (bx === spot.x && bz === spot.z) continue;
                                if (bx === spot.x+1 && bz === spot.z) continue;
                                if (bx === spot.x && bz === spot.z+1) continue;
                                if (bx === spot.x+1 && bz === spot.z+1) continue;
                                
                                const bk = `${bx},${bz}`;
                                bufferCells.push(bk);
                                // If any buffer cell is already occupied by another special building, skip
                                if (occupied.has(bk)) bufferClear = false;
                                // If buffer cell is a road, also skip!
                                if (isValid(bx, bz) && map[bx][bz] === 1) bufferClear = false;
                            }
                        }

                        if (bufferClear) {
                            specialMap[k1] = 'stadium_tl'; // Top-Left (Anchor)
                            stadiumCount++;
                            
                            // Mark main cells
                            specialMap[k2] = 'occupied';
                            specialMap[k3] = 'occupied';
                            specialMap[k4] = 'occupied';
                            occupied.add(k1); occupied.add(k2); occupied.add(k3); occupied.add(k4);

                            // Mark buffer cells as 'occupied' so no other buildings spawn there
                            // (Standard buildings check specialMap too)
                            bufferCells.forEach(bk => {
                                specialMap[bk] = 'occupied';
                                occupied.add(bk);
                            });
                        }
                    } else if (supermarketCount < 2) {
                        specialMap[k1] = 'supermarket_tl'; // Top-Left (Anchor)
                        supermarketCount++;
                        
                        specialMap[k2] = 'occupied';
                        specialMap[k3] = 'occupied';
                        specialMap[k4] = 'occupied';
                        
                        occupied.add(k1); occupied.add(k2); occupied.add(k3); occupied.add(k4);
                    } else {
                        specialMap[k1] = 'school_tl'; // Top-Left (Anchor)
                        schoolCount++;
                        
                        specialMap[k2] = 'occupied';
                        specialMap[k3] = 'occupied';
                        specialMap[k4] = 'occupied';
                        
                        occupied.add(k1); occupied.add(k2); occupied.add(k3); occupied.add(k4);
                    }
                }
            }

            // Assign Hospitals (4 Hospitals, 1x1)
            let hospitalCount = 0;
            for (const spot of validSpots) {
                if (hospitalCount >= 4) break;
                
                const k = `${spot.x},${spot.z}`;
                if (!occupied.has(k) && !specialMap[k]) {
                    specialMap[k] = 'hospital';
                    occupied.add(k);
                    hospitalCount++;
                }
            }

            // Assign Police Departments (skala berdasar grid, 1x1)
            // Menggunakan rasio grid agar "security parameter" konsisten dengan ukuran kota
            const policeTarget = Math.max(3, Math.floor(config.gridSize / 20)); // contoh: grid 80 ‚Üí 4
            let policeCount = 0;
            for (const spot of validSpots) {
                if (policeCount >= policeTarget) break;
                const k = `${spot.x},${spot.z}`;
                if (!occupied.has(k) && !specialMap[k]) {
                    specialMap[k] = 'police';
                    occupied.add(k);
                    policeCount++;
                }
            }

            // --- STEP 3: RENDER LOOP & INSTANCING SETUP ---
            // --- INSTANCING VARIABLES ---
            const roadInstances = [];
            const roadGeo = new THREE.PlaneGeometry(config.cellSize, config.cellSize);
            // FIXED: Use StandardMaterial with dark color to prevent blinding bloom at night
            const roadMat = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50, // Dark Asphalt Blue-Grey
                roughness: 0.9,
                metalness: 0.1
            });

            const swWidth = 2;
            const swInstancesNS = [];
            const swGeoNS = new THREE.PlaneGeometry(config.cellSize, swWidth);
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.9 });

            const swInstancesEW = [];
            const swGeoEW = new THREE.PlaneGeometry(swWidth, config.cellSize);

            // Parks
            const parkInstances = [];
            const parkGeo = new THREE.PlaneGeometry(config.cellSize, config.cellSize);
            const parkMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1 });

            // Trees
            const treeTrunkInstances = [];
            const treeCrownInstances = [];
            const treeTrunkColors = [];
            const treeCrownColors = [];
            const treeTrunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 1, 6);
            const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const treeCrownGeo = new THREE.SphereGeometry(1, 8, 8);
            const treeCrownMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const dummy = new THREE.Object3D();
            const _treeBrowns = [0x8B4513, 0xA0522D, 0xCD853F];
            const _treeGreens = [0x228B22, 0x006400, 0x32CD32, 0x556B2F];

            for (let x = 0; x < config.gridSize; x++) {
                for (let z = 0; z < config.gridSize; z++) {
                    const posX = (x * config.cellSize) - offset;
                    const posZ = (z * config.cellSize) - offset;

                    if (map[x][z] === 1) {
                        // --- ROAD (Instanced) ---
                        dummy.position.set(posX, 0.05, posZ);
                        dummy.rotation.set(-Math.PI / 2, 0, 0);
                        dummy.scale.set(1, 1, 1);
                        dummy.updateMatrix();
                        roadInstances.push(dummy.matrix.clone());

                        // --- ADD SIDEWALKS ---
                        const nIsRoad = isValid(x, z - 1) && map[x][z - 1] === 1;
                        const sIsRoad = isValid(x, z + 1) && map[x][z + 1] === 1;
                        const eIsRoad = isValid(x + 1, z) && map[x + 1][z] === 1;
                        const wIsRoad = isValid(x - 1, z) && map[x - 1][z] === 1;

                        // North sidewalk
                        if (!nIsRoad && isValid(x, z - 1)) {
                            dummy.position.set(posX, 0.08, posZ - (config.cellSize / 2 - swWidth / 2));
                            dummy.rotation.set(-Math.PI / 2, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            swInstancesNS.push(dummy.matrix.clone());

                            if (Math.random() < 0.15) {
                                createBench(posX, posZ - (config.cellSize / 2 - swWidth / 2), 0);
                                const offset = Math.random() < 0.5 ? -2.5 : 2.5;
                                createTrashCan(posX + offset, posZ - (config.cellSize / 2 - swWidth / 2));
                            }
                        }

                        // South sidewalk
                        if (!sIsRoad && isValid(x, z + 1)) {
                            dummy.position.set(posX, 0.08, posZ + (config.cellSize / 2 - swWidth / 2));
                            dummy.rotation.set(-Math.PI / 2, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            swInstancesNS.push(dummy.matrix.clone());

                            if (Math.random() < 0.15) {
                                createBench(posX, posZ + (config.cellSize / 2 - swWidth / 2), Math.PI);
                                const offset = Math.random() < 0.5 ? -2.5 : 2.5;
                                createTrashCan(posX + offset, posZ + (config.cellSize / 2 - swWidth / 2));
                            }
                        }

                        // East sidewalk
                        if (!eIsRoad && isValid(x + 1, z)) {
                            dummy.position.set(posX + (config.cellSize / 2 - swWidth / 2), 0.08, posZ);
                            dummy.rotation.set(-Math.PI / 2, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            swInstancesEW.push(dummy.matrix.clone());

                            if (Math.random() < 0.15) {
                                createBench(posX + (config.cellSize / 2 - swWidth / 2), posZ, -Math.PI / 2);
                                const offset = Math.random() < 0.5 ? -2.5 : 2.5;
                                createTrashCan(posX + (config.cellSize / 2 - swWidth / 2), posZ + offset);
                            }
                        }

                        // West sidewalk
                        if (!wIsRoad && isValid(x - 1, z)) {
                            dummy.position.set(posX - (config.cellSize / 2 - swWidth / 2), 0.08, posZ);
                            dummy.rotation.set(-Math.PI / 2, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            swInstancesEW.push(dummy.matrix.clone());

                            if (Math.random() < 0.15) {
                                createBench(posX - (config.cellSize / 2 - swWidth / 2), posZ, Math.PI / 2);
                                const offset = Math.random() < 0.5 ? -2.5 : 2.5;
                                createTrashCan(posX - (config.cellSize / 2 - swWidth / 2), posZ + offset);
                            }
                        }

                        // --- FIXED CAR LOGIC ---
                        // Count how many road neighbors this tile has
                        const roadNeighbors = [nIsRoad, sIsRoad, eIsRoad, wIsRoad].filter(Boolean).length;

                        // Only spawn cars on straight roads (2 neighbors in line)
                        // Intersections (3-4 neighbors) are too complex for simple car logic
                        let validAxis = null;

                        if (roadNeighbors === 2) {
                            // Vertical road (N-S connection)
                            if (nIsRoad && sIsRoad) validAxis = 'z';
                            // Horizontal road (E-W connection)
                            else if (eIsRoad && wIsRoad) validAxis = 'x';
                        }

                        // Spawn Car with higher probability for busy streets
                        if (validAxis && Math.random() < 0.45) {
                            createCar(posX, posZ, validAxis === 'z');
                        }

                        // Tambahkan lampu jalan di sidewalk pada persimpangan
                        if (x % 6 === 0 && z % 6 === 0) {
                            // Position lamp on the sidewalk corner (slightly offset from road center)
                            const lampOffset = (config.cellSize / 2) - 1.5; // Place on sidewalk edge
                            createLampPost(posX + lampOffset, posZ + lampOffset);
                        }
                    } else {
                        // Check valid city area before building
                        if (!isInsideCity(x, z)) continue;

                        // Check Special Buildings (Hospital/School)
                         const spKey = `${x},${z}`;
                         if (specialMap[spKey]) {
                         if (specialMap[spKey] === 'hospital') createHospital(posX, posZ);
                         else if (specialMap[spKey] === 'police') createPoliceDepartment(posX, posZ);
                         else if (specialMap[spKey] === 'school_tl') createSchool(posX, posZ);
                         else if (specialMap[spKey] === 'supermarket_tl') createSupermarket(posX, posZ);
                         else if (specialMap[spKey] === 'stadium_tl') createStadium(posX, posZ);
                         // 'occupied' spots are skipped automatically
                         continue;
                         }

                        // Parks (Instanced)
                        if (Math.random() < 0.24) {
                            // Park Ground
                            dummy.position.set(posX, 0.05, posZ);
                            dummy.rotation.set(-Math.PI / 2, 0, 0);
                            dummy.scale.set(1, 1, 1);
                            dummy.updateMatrix();
                            parkInstances.push(dummy.matrix.clone());

                            // Trees
                            const treeCount = 3 + Math.floor(Math.random() * 4);
                            for(let t=0; t<treeCount; t++) {
                                const tx = posX + (Math.random() * 10 - 5);
                                const tz = posZ + (Math.random() * 10 - 5);
                                const height = 4 + Math.random() * 5;
                                const crownScale = 2.8 + Math.random() * 2.8;

                                // Trunk
                                dummy.position.set(tx, height / 2, tz);
                                dummy.rotation.set(0, Math.random() * Math.PI, 0);
                                dummy.scale.set(1, height, 1);
                                dummy.updateMatrix();
                                treeTrunkInstances.push(dummy.matrix.clone());
                                
                                const tColor = new THREE.Color(_treeBrowns[Math.floor(Math.random()*_treeBrowns.length)]);
                                treeTrunkColors.push(tColor.r, tColor.g, tColor.b);

                                // Crown
                                dummy.position.set(tx, height + crownScale * 0.4, tz);
                                dummy.rotation.set(0, 0, 0);
                                dummy.scale.set(crownScale, crownScale, crownScale);
                                dummy.updateMatrix();
                                treeCrownInstances.push(dummy.matrix.clone());

                                const cColor = new THREE.Color(_treeGreens[Math.floor(Math.random()*_treeGreens.length)]);
                                treeCrownColors.push(cColor.r, cColor.g, cColor.b);
                            }
                            continue;
                        }

                        // Jika bukan jalan dan bukan taman, Buat Gedung
                        let height = Math.random() * 40 + 8; // Tinggi acak 8-48

                        // Sebagian kecil blok menjadi gedung pencakar langit (skyscraper) yang jauh lebih tinggi
                        const isSkyscraper = Math.random() < 0.12 && height > 30;
                        if (isSkyscraper) {
                            height = 30 + Math.random() * 60; // 60‚Äì130 unit
                        }

                        // Variasi gaya massa gedung (memberi bentuk berbeda-beda)
                        const styleRand = Math.random();
                        let buildingStyle = 'standard';
                        if (isSkyscraper) {
                            buildingStyle = styleRand < 0.5 ? 'slim-tower' : 'offset-tower';
                        } else if (styleRand < 0.2) {
                            buildingStyle = 'podium-tower';
                        } else if (styleRand < 0.4) {
                            buildingStyle = 'terraced-roof';
                        } else if (styleRand < 0.6) {
                            buildingStyle = 'twin-block';
                        } else if (styleRand < 0.8) {
                            buildingStyle = 'courtyard-block';
                        } // sisanya tetap "standard"

                        // Jika gedung tinggi, mungkin punya atap kecil (topper)
                        const hasTopper = height > 25 && Math.random() > 0.5;
                        // Apakah gedungnya kaca (glass) atau beton?
                        const isGlass = Math.random() > 0.6;

                        // Geometri Gedung utama (Kotak)
                        const baseSize = config.cellSize - 2;
                        let baseWidth = baseSize;
                        let baseDepth = baseSize;
                        if (buildingStyle === 'slim-tower') {
                            baseWidth *= 0.6;
                            baseDepth *= 0.6;
                        } else if (buildingStyle === 'podium-tower') {
                            baseWidth *= 0.9;
                            baseDepth *= 0.9;
                        }
                        const buildingGeo = new THREE.BoxGeometry(baseWidth, height, baseDepth);
                        buildingGeo.translate(0, height / 2, 0); // Geser pivot ke bawah

                        const bColor = getRandomBuildingColor(); // Ambil warna
                        const buildingMat = new THREE.MeshStandardMaterial({
                            color: bColor,
                            roughness: isGlass ? 0.1 : 0.8, // Kaca lebih licin
                            metalness: isGlass ? 0.9 : 0.2, // Kaca lebih metalik
                        });

                        const building = new THREE.Mesh(buildingGeo, buildingMat);
                        building.position.set(posX, 0, posZ);
                        building.castShadow = true; // Gedung buat bayangan
                        building.receiveShadow = true; // Gedung terima bayangan

                        if (isSkyscraper) {
                            addSkyscraperWindows(posX, posZ, baseWidth, baseDepth, height);
                            // Add detailed rooftop and facade
                            addRooftopDetails(building, baseWidth, baseDepth, height);
                            addFacadeDetails(building, baseWidth, baseDepth, height, buildingStyle, true);
                        } else {
                            addBuildingWindows(posX, posZ, baseWidth, baseDepth, height);
                            // Add details to standard buildings too
                            if (Math.random() < 0.7) addRooftopDetails(building, baseWidth, baseDepth, height);
                            addFacadeDetails(building, baseWidth, baseDepth, height, buildingStyle, false);
                        }

                        // Tambahkan struktur atap kecil jika 'hasTopper' true
                        if (hasTopper) {
                            const topperHeight = height * 0.3;
                            const topperWidth = baseWidth * 0.6;
                            const topperGeo = new THREE.BoxGeometry(topperWidth, topperHeight, topperWidth);
                            topperGeo.translate(0, topperHeight / 2, 0);
                            const topper = new THREE.Mesh(topperGeo, buildingMat);
                            topper.position.y = height; // Taruh di atas gedung utama
                            building.add(topper);
                        }

                        // Tambahan bentuk berdasarkan gaya bangunan
                        if (buildingStyle === 'podium-tower' && !isSkyscraper) {
                            // Podium rendah dan lebar di dasar
                            const podiumHeight = height * 0.25;
                            const podiumGeo = new THREE.BoxGeometry(baseSize * 1.1, podiumHeight, baseSize * 1.1);
                            podiumGeo.translate(0, podiumHeight / 2, 0);
                            const podium = new THREE.Mesh(podiumGeo, buildingMat);
                            podium.receiveShadow = true;
                            building.add(podium);
                        } else if (buildingStyle === 'terraced-roof') {
                            // Satu atau dua volume lebih kecil di atap (teras bertingkat)
                            const terraceLevels = 1 + Math.floor(Math.random() * 2);
                            for (let i = 0; i < terraceLevels; i++) {
                                const levelHeight = height * 0.12;
                                const scale = 0.6 - i * 0.15;
                                const terraceGeo = new THREE.BoxGeometry(baseWidth * scale, levelHeight, baseDepth * scale);
                                terraceGeo.translate(0, levelHeight / 2, 0);
                                const terrace = new THREE.Mesh(terraceGeo, buildingMat);
                                terrace.position.y = height * (0.6 + i * 0.15);
                                terrace.castShadow = true;
                                terrace.receiveShadow = true;
                                building.add(terrace);
                            }
                        } else if (buildingStyle === 'twin-block') {
                            // Blok kembar yang saling menempel
                            const wingHeight = height * 0.7;
                            const wingGeo = new THREE.BoxGeometry(baseWidth * 0.6, wingHeight, baseDepth * 0.6);
                            wingGeo.translate(0, wingHeight / 2, 0);
                            const wing = new THREE.Mesh(wingGeo, buildingMat);
                            wing.position.set(baseWidth * 0.6, 0, 0);
                            wing.castShadow = true;
                            wing.receiveShadow = true;
                            building.add(wing);
                        } else if (buildingStyle === 'offset-tower') {
                            // Bagian atas gedung bergeser sedikit, memberi siluet yang unik
                            const upperHeight = height * 0.45;
                            const upperGeo = new THREE.BoxGeometry(baseWidth * 0.7, upperHeight, baseDepth * 0.7);
                            upperGeo.translate(0, upperHeight / 2, 0);
                            const upper = new THREE.Mesh(upperGeo, buildingMat);
                            upper.position.set(baseWidth * 0.25, height * 0.45, baseDepth * -0.2);
                            upper.castShadow = true;
                            upper.receiveShadow = true;
                            building.add(upper);
                        } else if (buildingStyle === 'courtyard-block') {
                            // Blok besar dengan "courtyard" di tengah (4 sayap mengelilingi ruang kosong)
                            const wingHeight = height * 0.55;
                            const wingThickness = baseWidth * 0.32;
                            const wingLength = baseWidth * 0.95;
                            const wingGeo = new THREE.BoxGeometry(wingThickness, wingHeight, wingLength);
                            wingGeo.translate(0, wingHeight / 2, 0);
                            const wingMat = buildingMat;

                            const north = new THREE.Mesh(wingGeo, wingMat);
                            north.position.set(0, 0, baseDepth * 0.45);

                            const south = new THREE.Mesh(wingGeo, wingMat);
                            south.position.set(0, 0, -baseDepth * 0.45);

                            const east = new THREE.Mesh(wingGeo, wingMat);
                            east.rotation.y = Math.PI / 2;
                            east.position.set(baseWidth * 0.45, 0, 0);

                            const west = new THREE.Mesh(wingGeo, wingMat);
                            west.rotation.y = Math.PI / 2;
                            west.position.set(-baseWidth * 0.45, 0, 0);

                            [north, south, east, west].forEach(w => {
                                w.castShadow = true;
                                w.receiveShadow = true;
                                building.add(w);
                            });
                        }

                        // Tentukan tipe bangunan yang lebih bervariasi
                        let typeLabel;
                        if (isSkyscraper) {
                            typeLabel = buildingStyle === 'offset-tower'
                                ? "Iconic Offset Tower"
                                : "Mixed-Use Skyline Tower";
                        } else if (buildingStyle === 'podium-tower') {
                            typeLabel = "Podium Office Tower";
                        } else if (buildingStyle === 'terraced-roof') {
                            typeLabel = "Terraced Residential Block";
                        } else if (buildingStyle === 'twin-block') {
                            typeLabel = "Twin Block Complex";
                        } else if (buildingStyle === 'courtyard-block') {
                            typeLabel = "Courtyard Civic Block";
                        } else if (height > 35) {
                            typeLabel = "Corporate HQ";
                        } else if (height > 22) {
                            typeLabel = Math.random() < 0.5 ? "Mid-Rise Apartments" : "Business Hotel";
                        } else if (height > 14) {
                            typeLabel = Math.random() < 0.5 ? "Residential Row" : "Community Housing";
                        } else {
                            typeLabel = Math.random() < 0.5 ? "Retail Podium" : "Low-Rise Shops";
                        }

                        // Simpan data simulasi ke dalam objek gedung (userData)
                        // Power Demand Calculation: Volume * Factor
                        const volume = baseSize * baseSize * height;
                        let powerFactor = 0.5; // kWh per unit volume per day (arbitrary)
                        if (isSkyscraper) powerFactor = 1.2;
                        if (typeLabel.includes("Commercial") || typeLabel.includes("Retail") || typeLabel.includes("HQ")) powerFactor = 1.5;
                        
                        const estimatedDemand = Math.floor(volume * powerFactor * 0.01); // in kW

                        building.userData = {
                            id: `B-${x}-${z}`, // ID unik
                            type: typeLabel,
                            pollution: Math.floor(Math.random() * 100), // Data polusi acak
                            energy: estimatedDemand,    // Data energi realistis
                            traffic: Math.floor(Math.random() * 100),   // Data trafik acak
                            originalColor: bColor, // Simpan warna asli untuk reset nanti
                            windowIntensity: (Math.random() * 0.4) + 0.2 // Intensitas maksimal cahaya jendela di malam hari
                        };

                        // Sebagian gedung punya jendela bercahaya (emissive) yang akan menguat di malam hari
                        if (isSkyscraper) {
                            // Skyscraper: lebih banyak jendela bercahaya supaya tampak hidup di malam hari
                            building.material.emissive = new THREE.Color(0x777799);
                            building.material.emissiveIntensity = 0.08;
                        } else {
                            if (Math.random() > 0.3) {
                                building.material.emissive = new THREE.Color(0x555577);
                                building.material.emissiveIntensity = 0.05; // Nilai dasar siang hari (redup)
                            } else {
                                building.material.emissive = new THREE.Color(0x000000);
                                building.material.emissiveIntensity = 0.0;
                            }
                        }

                        scene.add(building); // Masukkan ke scene
                        buildings.push(building); // Masukkan ke array buildings
                    }
                }
            }

            // --- CREATE INSTANCED MESHES ---
            
            // 1. Roads
            if (roadInstances.length > 0) {
                const roadInstMesh = new THREE.InstancedMesh(roadGeo, roadMat, roadInstances.length);
                for (let i = 0; i < roadInstances.length; i++) {
                    roadInstMesh.setMatrixAt(i, roadInstances[i]);
                }
                roadInstMesh.receiveShadow = true;
                scene.add(roadInstMesh);
            }

            // 2. Sidewalks NS
            if (swInstancesNS.length > 0) {
                const swInstMeshNS = new THREE.InstancedMesh(swGeoNS, sidewalkMat, swInstancesNS.length);
                for (let i = 0; i < swInstancesNS.length; i++) {
                    swInstMeshNS.setMatrixAt(i, swInstancesNS[i]);
                }
                swInstMeshNS.receiveShadow = true;
                scene.add(swInstMeshNS);
            }

            // 3. Sidewalks EW
            if (swInstancesEW.length > 0) {
                const swInstMeshEW = new THREE.InstancedMesh(swGeoEW, sidewalkMat, swInstancesEW.length);
                for (let i = 0; i < swInstancesEW.length; i++) {
                    swInstMeshEW.setMatrixAt(i, swInstancesEW[i]);
                }
                swInstMeshEW.receiveShadow = true;
                scene.add(swInstMeshEW);
            }

            // 4. Parks
            if (parkInstances.length > 0) {
                const parkInstMesh = new THREE.InstancedMesh(parkGeo, parkMat, parkInstances.length);
                for (let i = 0; i < parkInstances.length; i++) {
                    parkInstMesh.setMatrixAt(i, parkInstances[i]);
                }
                parkInstMesh.receiveShadow = true;
                scene.add(parkInstMesh);
            }

            // 5. Trees
            if (treeTrunkInstances.length > 0) {
                const trunkMesh = new THREE.InstancedMesh(treeTrunkGeo, treeTrunkMat, treeTrunkInstances.length);
                const crownMesh = new THREE.InstancedMesh(treeCrownGeo, treeCrownMat, treeCrownInstances.length);
                
                for(let i=0; i<treeTrunkInstances.length; i++) {
                    trunkMesh.setMatrixAt(i, treeTrunkInstances[i]);
                    trunkMesh.setColorAt(i, new THREE.Color(treeTrunkColors[3*i], treeTrunkColors[3*i+1], treeTrunkColors[3*i+2]));
                    
                    crownMesh.setMatrixAt(i, treeCrownInstances[i]);
                    crownMesh.setColorAt(i, new THREE.Color(treeCrownColors[3*i], treeCrownColors[3*i+1], treeCrownColors[3*i+2]));
                }
                trunkMesh.castShadow = true;
                trunkMesh.receiveShadow = true;
                crownMesh.castShadow = true;
                crownMesh.receiveShadow = true;
                
                scene.add(trunkMesh);
                scene.add(crownMesh);
            }

            windowMesh.count = windowInstanceCount;
            windowMesh.instanceMatrix.needsUpdate = true;
            skyscraperWindowMesh.count = skyscraperWindowInstanceCount;
            skyscraperWindowMesh.instanceMatrix.needsUpdate = true;
        }

        // Fungsi Membuat Mobil
        // Function to Create a Car with Proper Lane Logic
        // Fungsi Membuat Mobil with Grid-Based Pathfinding
        const carAssets = {
            geometries: {
                box: new THREE.BoxGeometry(1, 1, 1),
                wheel: new THREE.CylinderGeometry(1, 1, 1, 16)
            },
            materials: {
                rubber: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 }),
                chrome: new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.1 }),
                glass: new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.9,
                    roughness: 0.05,
                    transparent: true,
                    opacity: 0.85
                }),
                headLight: new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffffaa, emissiveIntensity: 5 }),
                tailLight: new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 3 }),
                paints: {}
            },
            getPaint: function(color) {
                if (!this.materials.paints[color]) {
                    this.materials.paints[color] = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.6,
                        roughness: 0.2,
                        envMapIntensity: 1.5
                    });
                }
                return this.materials.paints[color];
            }
        };

        function createCar(x, z, isVertical) {
            const carGroup = new THREE.Group();

            // Randomly determine vehicle type
            const vehicleTypeRand = Math.random();
            let vehicleType, vehicleConfig;

            if (vehicleTypeRand < 0.5) {
                // 50% Personal Car
                vehicleType = 'car';
                vehicleConfig = {
                    width: 2,
                    height: 1.2,
                    length: 3.5,
                    pollution: 60,      // Medium pollution
                    greenness: 50,      // Medium greenness
                    topSpeed: 0.25 + Math.random() * 0.15,
                    colors: [0x0088ff, 0xff4444, 0x44ff44, 0xffaa00, 0xff00ff, 0x00ffff, 0xffffff, 0x333333]
                };
            } else if (vehicleTypeRand < 0.8) {
                // 30% Truck
                vehicleType = 'truck';
                vehicleConfig = {
                    width: 2.5,
                    height: 2.2,
                    length: 5.5,
                    pollution: 90,      // High pollution (worst)
                    greenness: 20,      // Low greenness (worst)
                    topSpeed: 0.20 + Math.random() * 0.10,
                    colors: [0x8b4513, 0x654321, 0x2f4f4f, 0x696969, 0x556b2f]
                };
            } else {
                // 20% Bus
                vehicleType = 'bus';
                vehicleConfig = {
                    width: 2.8,
                    height: 3.0,
                    length: 6.5,
                    pollution: 30,      // Low pollution (best)
                    greenness: 80,      // High greenness (best)
                    topSpeed: 0.22 + Math.random() * 0.12,
                    colors: [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff]
                };
            }

            const color = vehicleConfig.colors[Math.floor(Math.random() * vehicleConfig.colors.length)];
            const paintMat = carAssets.getPaint(color);
            const rubberMat = carAssets.materials.rubber;
            const chromeMat = carAssets.materials.chrome;

            // --- 3. Car Construction Dimensions ---
            const groundClearance = vehicleConfig.height * 0.25;
            const chassisHeight = vehicleConfig.height * 0.45;
            const cabinHeight = vehicleConfig.height * 0.35;
            const wheelRadius = groundClearance * 1.3;
            const wheelWidth = vehicleConfig.width * 0.18;


            // --- 4. Build The Body Parts ---

            // A. The Main Chassis (Lower Body)
            const carBody = new THREE.Mesh(carAssets.geometries.box, paintMat);
            carBody.scale.set(vehicleConfig.width, chassisHeight, vehicleConfig.length);
            carBody.position.y = groundClearance + chassisHeight / 2;
            carBody.castShadow = true;
            carGroup.add(carBody);

            // B. The Cabin (Upper Glass area)
            const cabin = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.glass);
            cabin.scale.set(vehicleConfig.width * 0.8, cabinHeight, vehicleConfig.length * 0.5);
            cabin.position.set(0, groundClearance + chassisHeight + cabinHeight / 2, -vehicleConfig.length * 0.1);
            carGroup.add(cabin);


            // --- 5. Add Details (Lights & Bumpers) ---

            const frontBumper = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.rubber);
            frontBumper.scale.set(vehicleConfig.width * 1.02, chassisHeight * 0.2, vehicleConfig.length * 0.05);
            frontBumper.position.set(0, groundClearance + chassisHeight * 0.1, vehicleConfig.length / 2);
            carGroup.add(frontBumper);

            const rearBumper = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.rubber);
            rearBumper.scale.set(vehicleConfig.width * 1.02, chassisHeight * 0.2, vehicleConfig.length * 0.05);
            rearBumper.position.set(0, groundClearance + chassisHeight * 0.1, -vehicleConfig.length / 2);
            carGroup.add(rearBumper);

            const headLightL = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.headLight);
            headLightL.scale.set(vehicleConfig.width * 0.2, chassisHeight * 0.1, 0.1);
            headLightL.position.set(vehicleConfig.width * 0.3, groundClearance + chassisHeight * 0.25, vehicleConfig.length / 2 + 0.05);
            carGroup.add(headLightL);

            const headLightR = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.headLight);
            headLightR.scale.set(vehicleConfig.width * 0.2, chassisHeight * 0.1, 0.1);
            headLightR.position.set(-vehicleConfig.width * 0.3, groundClearance + chassisHeight * 0.25, vehicleConfig.length / 2 + 0.05);
            carGroup.add(headLightR);

            const tailLight = new THREE.Mesh(carAssets.geometries.box, carAssets.materials.tailLight);
            tailLight.scale.set(vehicleConfig.width * 0.8, chassisHeight * 0.15, 0.1);
            tailLight.position.set(0, groundClearance + chassisHeight * 0.2, -vehicleConfig.length / 2 - 0.05);
            carGroup.add(tailLight);


            const createSportsWheel = (x, y, z) => {
                const wheelGroup = new THREE.Group();
                wheelGroup.position.set(x, y, z);
                const tire = new THREE.Mesh(carAssets.geometries.wheel, carAssets.materials.rubber);
                tire.rotation.z = Math.PI / 2;
                tire.scale.set(wheelRadius, wheelWidth, wheelRadius);
                tire.castShadow = true;
                wheelGroup.add(tire);
                const rim = new THREE.Mesh(carAssets.geometries.wheel, carAssets.materials.chrome);
                rim.rotation.z = Math.PI / 2;
                rim.scale.set(wheelRadius * 0.65, wheelWidth * 1.1, wheelRadius * 0.65);
                wheelGroup.add(rim);

                return wheelGroup;
            };

            const wheelOffsetZ = vehicleConfig.length * 0.32;
            const wheelOffsetX = vehicleConfig.width / 2 - (wheelWidth / 4);

            carGroup.add(createSportsWheel(wheelOffsetX, wheelRadius, wheelOffsetZ));
            carGroup.add(createSportsWheel(-wheelOffsetX, wheelRadius, wheelOffsetZ));
            carGroup.add(createSportsWheel(wheelOffsetX, wheelRadius, -wheelOffsetZ));
            carGroup.add(createSportsWheel(-wheelOffsetX, wheelRadius, -wheelOffsetZ));


            // --- Shared Reusable Materials ---
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x88ccff, roughness: 0.1, metalness: 0.9, transparent: true, opacity: 0.7
            });
            const lightGlowMat = new THREE.MeshStandardMaterial({
                color: 0xffffcc, emissive: 0xffffaa, emissiveIntensity: 2
            });

            // Helper function to create a detailed wheel (Optimized)
            const createWheel = (radius, width, x, y, z) => {
                const wheelGroup = new THREE.Group();

                // Tire
                const tire = new THREE.Mesh(carAssets.geometries.wheel, carAssets.materials.rubber);
                tire.rotation.z = Math.PI / 2;
                tire.scale.set(radius, width, radius);
                tire.castShadow = true;
                wheelGroup.add(tire);

                // Rim
                const rim = new THREE.Mesh(carAssets.geometries.wheel, carAssets.materials.chrome);
                rim.rotation.z = Math.PI / 2;
                rim.scale.set(radius * 0.6, width * 1.05, radius * 0.6);
                wheelGroup.add(rim);

                wheelGroup.position.set(x, y, z);
                return wheelGroup;
            };


            // --- Vehicle Specific Features ---

            if (vehicleType === 'truck') {
                // 1. THE CABIN (Front)
                const cabHeight = vehicleConfig.height * 0.7;
                const cabLen = vehicleConfig.length * 0.25;
                const cabGeo = new THREE.BoxGeometry(vehicleConfig.width, cabHeight, cabLen);
                const cabMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5, metalness: 0.3 }); // Red Truck
                const cabin = new THREE.Mesh(cabGeo, cabMat);
                cabin.position.set(0, cabHeight / 2 + (vehicleConfig.height * 0.1), vehicleConfig.length * 0.35);
                cabin.castShadow = true;
                carGroup.add(cabin);

                // Windshield
                const windGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.9, cabHeight * 0.4, 0.1);
                const windshield = new THREE.Mesh(windGeo, glassMat);
                windshield.position.set(0, cabHeight * 0.2, cabLen / 2 + 0.05);
                cabin.add(windshield); // Add relative to cabin

                // Grille
                const grilleGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.7, cabHeight * 0.4, 0.1);
                const grille = new THREE.Mesh(grilleGeo, chromeMat);
                grille.position.set(0, -cabHeight * 0.2, cabLen / 2 + 0.05);
                cabin.add(grille);

                // Exhaust Stacks (Chrome pipes)
                const pipeGeo = new THREE.CylinderGeometry(0.1, 0.1, cabHeight * 1.2, 8);
                const pipe1 = new THREE.Mesh(pipeGeo, chromeMat);
                const pipe2 = pipe1.clone();
                pipe1.position.set(vehicleConfig.width * 0.55, cabHeight * 0.6, -cabLen * 0.4);
                pipe2.position.set(-vehicleConfig.width * 0.55, cabHeight * 0.6, -cabLen * 0.4);
                cabin.add(pipe1);
                cabin.add(pipe2);

                // 2. THE TRAILER (Cargo)
                const cargoGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.95, vehicleConfig.height * 0.8, vehicleConfig.length * 0.65);
                const cargoMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff, roughness: 0.8, bumpScale: 0.05
                });
                const cargo = new THREE.Mesh(cargoGeo, cargoMat);
                cargo.position.set(0, vehicleConfig.height * 0.5, -vehicleConfig.length * 0.15);
                cargo.castShadow = true;
                carGroup.add(cargo);

                // 3. WHEELS (Truck needs lots of wheels)
                const wheelRadius = vehicleConfig.height * 0.15;
                const wheelWidth = vehicleConfig.width * 0.15;
                const groundClearance = wheelRadius;

                // Front Cab Wheels
                carGroup.add(createWheel(wheelRadius, wheelWidth, vehicleConfig.width / 2, groundClearance, vehicleConfig.length * 0.35));
                carGroup.add(createWheel(wheelRadius, wheelWidth, -vehicleConfig.width / 2, groundClearance, vehicleConfig.length * 0.35));

                // Rear Trailer Wheels (Double axle)
                const rearZ = -vehicleConfig.length * 0.3;
                carGroup.add(createWheel(wheelRadius, wheelWidth, vehicleConfig.width / 2, groundClearance, rearZ));
                carGroup.add(createWheel(wheelRadius, wheelWidth, -vehicleConfig.width / 2, groundClearance, rearZ));
                carGroup.add(createWheel(wheelRadius, wheelWidth, vehicleConfig.width / 2, groundClearance, rearZ - wheelRadius * 2.2));
                carGroup.add(createWheel(wheelRadius, wheelWidth, -vehicleConfig.width / 2, groundClearance, rearZ - wheelRadius * 2.2));

            } else if (vehicleType === 'bus') {
                // 1. BUS BODY
                const busBodyMat = new THREE.MeshStandardMaterial({ color: 0x1c86ee, roughness: 0.4 }); // Modern Blue

                // Main Hull
                const hullGeo = new THREE.BoxGeometry(vehicleConfig.width, vehicleConfig.height * 0.8, vehicleConfig.length);
                const busBody = new THREE.Mesh(hullGeo, busBodyMat);
                busBody.position.set(0, vehicleConfig.height * 0.5, 0);
                busBody.castShadow = true;
                carGroup.add(busBody);

                // Roof A/C Unit
                const acGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.6, 0.2, vehicleConfig.length * 0.2);
                const acUnit = new THREE.Mesh(acGeo, new THREE.MeshStandardMaterial({ color: 0xdddddd }));
                acUnit.position.set(0, vehicleConfig.height * 0.4 + 0.1, -vehicleConfig.length * 0.2);
                busBody.add(acUnit);

                // 2. WINDOWS STRIP (Running along the side)
                const sideWindowGeo = new THREE.BoxGeometry(vehicleConfig.width * 1.02, vehicleConfig.height * 0.3, vehicleConfig.length * 0.85);
                const sideWindow = new THREE.Mesh(sideWindowGeo, glassMat);
                sideWindow.position.set(0, vehicleConfig.height * 0.1, 0);
                busBody.add(sideWindow);

                // Front Windshield
                const frontWinGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.9, vehicleConfig.height * 0.4, 0.1);
                const frontWindow = new THREE.Mesh(frontWinGeo, glassMat);
                frontWindow.position.set(0, 0, vehicleConfig.length / 2 + 0.05);
                busBody.add(frontWindow);

                // 3. LIGHTS
                // Headlights
                const hlGeo = new THREE.BoxGeometry(vehicleConfig.width * 0.15, 0.1, 0.1);
                const hlLeft = new THREE.Mesh(hlGeo, lightGlowMat);
                const hlRight = new THREE.Mesh(hlGeo, lightGlowMat);
                hlLeft.position.set(vehicleConfig.width * 0.3, -vehicleConfig.height * 0.2, vehicleConfig.length / 2 + 0.05);
                hlRight.position.set(-vehicleConfig.width * 0.3, -vehicleConfig.height * 0.2, vehicleConfig.length / 2 + 0.05);
                busBody.add(hlLeft);
                busBody.add(hlRight);

                // 4. WHEELS
                const wheelRadius = vehicleConfig.height * 0.15;
                const wheelWidth = vehicleConfig.width * 0.1;
                const groundClearance = wheelRadius;

                carGroup.add(createWheel(wheelRadius, wheelWidth, vehicleConfig.width / 2 * 0.9, groundClearance, vehicleConfig.length * 0.3));
                carGroup.add(createWheel(wheelRadius, wheelWidth, -vehicleConfig.width / 2 * 0.9, groundClearance, vehicleConfig.length * 0.3));
                carGroup.add(createWheel(wheelRadius, wheelWidth, vehicleConfig.width / 2 * 0.9, groundClearance, -vehicleConfig.length * 0.3));
                carGroup.add(createWheel(wheelRadius, wheelWidth, -vehicleConfig.width / 2 * 0.9, groundClearance, -vehicleConfig.length * 0.3));
            }

            const laneOffset = 2.2;
            const dir = Math.random() > 0.5 ? 1 : -1;

            let startX = x;
            let startZ = z;

            if (isVertical) {
                startX += (dir === 1) ? -laneOffset : laneOffset;
                carGroup.rotation.y = (dir === 1) ? 0 : Math.PI;
            } else {
                startZ += (dir === 1) ? laneOffset : -laneOffset;
                carGroup.rotation.y = (dir === 1) ? Math.PI / 2 : -Math.PI / 2;
            }

            carGroup.position.set(startX, 0, startZ);

            // Convert world position to grid coordinates
            const offset = (config.gridSize * config.cellSize) / 2;
            const gridX = Math.floor((startX + offset) / config.cellSize);
            const gridZ = Math.floor((startZ + offset) / config.cellSize);

            // FIXED: Consistent lane offset calculation matching the direction change logic
            let laneOffsetX = 0;
            let laneOffsetZ = 0;

            if (isVertical) {
                // Moving vertically (North/South) - offset on X axis
                laneOffsetX = laneOffset * (dir === 1 ? -1 : 1);
                laneOffsetZ = 0;
            } else {
                // Moving horizontally (East/West) - offset on Z axis
                laneOffsetX = 0;
                laneOffsetZ = laneOffset * (dir === 1 ? 1 : -1);
            }

            carGroup.userData = {
                velocity: 0,
                topSpeed: vehicleConfig.topSpeed,
                acceleration: 0.015,
                braking: 0.04,
                axis: isVertical ? 'z' : 'x',
                direction: dir,
                limit: (config.gridSize * config.cellSize) / 2,
                gridX: gridX,
                gridZ: gridZ,
                targetGridX: gridX,
                targetGridZ: gridZ,
                laneOffset: laneOffsetX,
                laneOffsetZ: laneOffsetZ,
                vehicleType: vehicleType,
                pollution: vehicleConfig.pollution,
                greenness: vehicleConfig.greenness
            };

            scene.add(carGroup);
            cars.push(carGroup);
        }



        // Fungsi Membuat Lampu Jalan
        function createLampPost(x, z) {
            const lamp = new THREE.Group();

            // Tiang
            const poleHeight = 10;
            const poleGeo = new THREE.CylinderGeometry(0.15, 0.25, poleHeight, 10);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xd0d3d4, metalness: 0.8, roughness: 0.3 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.castShadow = true;
            pole.receiveShadow = true;
            pole.position.y = poleHeight / 2;
            lamp.add(pole);

            // Kepala lampu
            const headGeo = new THREE.SphereGeometry(0.7, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0xfff9c4,
                emissive: new THREE.Color(0x000000),
                emissiveIntensity: 0.0,
                roughness: 0.4,
                metalness: 0.2
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.castShadow = false;
            head.receiveShadow = false;
            head.position.y = poleHeight + 0.5;
            lamp.add(head);

            // Sumber cahaya aktual untuk lampu jalan (tanpa shadow supaya tidak berat)
            const light = new THREE.PointLight(0xfff2b3, 0.0, 40, 2.0);
            light.position.set(0, head.position.y, 0);
            light.castShadow = false;
            lamp.add(light);

            lamp.position.set(x, 0, z);

            scene.add(lamp);
            lampposts.push({ group: lamp, head });
            lampLights.push(light);
        }

        // Fungsi Membuat Bench
        function createBench(x, z, rotation = 0) {
            const bench = new THREE.Group();

            // Materials
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });

            // Seat
            const seatGeo = new THREE.BoxGeometry(3, 0.2, 1);
            const seat = new THREE.Mesh(seatGeo, woodMat);
            seat.position.y = 0.6; // Slightly lower than 1
            seat.castShadow = true;
            seat.receiveShadow = true;
            bench.add(seat);

            // Backrest
            const backGeo = new THREE.BoxGeometry(3, 1, 0.2);
            const back = new THREE.Mesh(backGeo, woodMat);
            back.position.set(0, 1.2, -0.4);
            back.rotation.x = -0.2; // Slight tilt
            back.castShadow = true;
            back.receiveShadow = true;
            bench.add(back);

            // Legs
            const legGeo = new THREE.BoxGeometry(0.2, 0.6, 1);
            const leftLeg = new THREE.Mesh(legGeo, metalMat);
            leftLeg.position.set(-1.2, 0.3, 0);
            bench.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, metalMat);
            rightLeg.position.set(1.2, 0.3, 0);
            bench.add(rightLeg);

            bench.position.set(x, 0, z);
            bench.rotation.y = rotation;
            
            // Add scale randomization for variety
            const scale = 0.8 + Math.random() * 0.2;
            bench.scale.set(scale, scale, scale);

            scene.add(bench);
        }

        // Fungsi Membuat Trash Can
        function createTrashCan(x, z) {
            const trash = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.4, 1.2, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            body.receiveShadow = true;
            trash.add(body);

            // Lid/Rim
            const rimGeo = new THREE.TorusGeometry(0.5, 0.05, 8, 16);
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.3 });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.rotation.x = Math.PI / 2;
            rim.position.y = 1.2;
            trash.add(rim);

            trash.position.set(x, 0, z);
            scene.add(trash);
        }

        // Fungsi Membuat Satu Pohon (batang + daun) dengan warna & tinggi yang bervariasi
        function createTree(x, z) {
            const tree = new THREE.Group();

            // Batang
            // Tinggi batang acak supaya pohon tidak seragam
            const trunkHeight = 4 + Math.random() * 5; // 4‚Äì9
            const trunkRadiusTop = 0.5 + Math.random() * 0.4;
            const trunkRadiusBottom = trunkRadiusTop + 0.2;
            const trunkGeo = new THREE.CylinderGeometry(trunkRadiusTop, trunkRadiusBottom, trunkHeight, 8);

            // Variasi warna batang (coklat tua, kemerahan, sedikit keabu-abuan)
            const trunkColors = [0x8b5a2b, 0x6e2c00, 0x7e5109, 0x5d4037, 0x4e342e];
            const trunkMat = new THREE.MeshStandardMaterial({
                color: trunkColors[Math.floor(Math.random() * trunkColors.length)],
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = trunkHeight / 2;
            tree.add(trunk);

            // Daun (mahkota pohon) dengan beberapa warna hijau yang berbeda
            const crownRadius = 2.8 + Math.random() * 2.8; // 2.8‚Äì5.6
            const crownGeo = new THREE.SphereGeometry(crownRadius, 16, 16);
            const crownColors = [
                0x1e8449, 0x27ae60, 0x239b56, 0x52be80, 0x196f3d, // hijau
                0x9a7d0a, 0xd68910, 0xb9770e,                     // kuning/coklat daun kering
                0x922b21, 0xc0392b                                 // merah daun musim gugur
            ];
            const crownMat = new THREE.MeshStandardMaterial({
                color: crownColors[Math.floor(Math.random() * crownColors.length)],
                roughness: 0.6,
                metalness: 0.1
            });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.castShadow = true;
            crown.receiveShadow = true;
            crown.position.y = trunkHeight + crownRadius * 0.4;
            tree.add(crown);

            tree.position.set(x, 0, z);
            scene.add(tree);
            trees.push(tree);
        }

        // Fungsi Membuat Taman kecil dengan beberapa pohon
        function createParkWithTrees(x, z) {
            // Rumput dasar taman
            const parkGeo = new THREE.PlaneGeometry(config.cellSize - 2, config.cellSize - 2);
            const parkMat = new THREE.MeshStandardMaterial({
                color: 0x145a32,
                roughness: 0.9
            });
            const park = new THREE.Mesh(parkGeo, parkMat);
            park.rotation.x = -Math.PI / 2;
            park.position.set(x, 0.02, z);
            park.receiveShadow = true;
            scene.add(park);

            // Beberapa pohon acak di dalam tile taman
            const treeCount = 3 + Math.floor(Math.random() * 4); // 3‚Äì6 pohon
            for (let i = 0; i < treeCount; i++) {
                const offsetX = (Math.random() - 0.5) * (config.cellSize - 4);
                const offsetZ = (Math.random() - 0.5) * (config.cellSize - 4);
                createTree(x + offsetX, z + offsetZ);
            }
        }


        // --- 6. ANIMASI LOOP UTAMA (moved up to fix initialization order) ---
        let timeOfDay = 0; // 0‚Äì1 mewakili 0‚Äì24 jam (0 = tengah malam, 0.5 = tengah hari)
        const weatherState = {
            current: 'clear',   // 'clear' | 'overcast' | 'rain'
            timer: 0,
            cloudFactor: 0,     // 0‚Äì1 seberapa banyak awan
            rainFactor: 0,      // 0‚Äì1 intensitas hujan
            darkenFactor: 0     // 0‚Äì1 seberapa gelap keseluruhan
        };

        createCity(); // Jalankan fungsi pembuatan kota
        initWeatherSystems(); // Inisialisasi awan dan hujan
        updateStats(); // Initialize stats panel

        // --- 5. INTERAKSI MOUSE (RAYCASTER) ---
        const raycaster = new THREE.Raycaster(); // Sinar laser tak terlihat untuk deteksi klik
        const mouse = new THREE.Vector2();       // Koordinat mouse

        // Event listener: Saat mouse bergerak & saat klik
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);

        // Fungsi saat mouse bergerak
        function onMouseMove(event) {
            // Normalisasi posisi mouse (-1 sampai +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera); // Tembak sinar dari kamera
            const intersects = raycaster.intersectObjects(buildings); // Cek kena gedung apa

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer'; // Ubah kursor jadi tangan
                const obj = intersects[0].object; // Ambil objek pertama yg kena

                // Jika pindah sorotan ke gedung baru
                if (state.hoveredObject !== obj) {
                    // Reset warna gedung lama
                    if (state.hoveredObject && state.hoveredObject !== state.selectedObject) {
                        gsap.to(state.hoveredObject.material.color, {
                            r: new THREE.Color(state.hoveredObject.userData.originalColor).r,
                            g: new THREE.Color(state.hoveredObject.userData.originalColor).g,
                            b: new THREE.Color(state.hoveredObject.userData.originalColor).b,
                            duration: 0.3
                        });
                    }
                    state.hoveredObject = obj;
                    // Ubah warna gedung baru jadi Cyan (Highlight)
                    if (obj !== state.selectedObject) {
                        gsap.to(obj.material.color, {
                            r: new THREE.Color(config.highlightColor).r,
                            g: new THREE.Color(config.highlightColor).g,
                            b: new THREE.Color(config.highlightColor).b,
                            duration: 0.3
                        });
                    }
                }
            } else {
                document.body.style.cursor = 'default'; // Kembalikan kursor biasa
                // Reset warna jika mouse keluar dari gedung
                if (state.hoveredObject && state.hoveredObject !== state.selectedObject) {
                    gsap.to(state.hoveredObject.material.color, {
                        r: new THREE.Color(state.hoveredObject.userData.originalColor).r,
                        g: new THREE.Color(state.hoveredObject.userData.originalColor).g,
                        b: new THREE.Color(state.hoveredObject.userData.originalColor).b,
                        duration: 0.3
                    });
                    state.hoveredObject = null;
                }
            }
        }

        // Fungsi saat klik mouse
        function onClick(event) {
            // Jika klik kena UI (tombol), jangan klik gedung di belakangnya
            if (event.target.closest('#ui-layer')) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                // Jika yg kena atap (topper), pilih gedung induknya (parent)
                if (obj.parent && obj.parent.userData.id) obj = obj.parent;
                selectBuilding(obj);
            } else {
                closePanel(); // Jika klik tanah kosong, tutup panel
            }
        }

        // Fungsi Memilih Gedung
        function selectBuilding(obj) {
            // Reset gedung yang dipilih sebelumnya
            if (state.selectedObject) {
                state.selectedObject.material.emissive = new THREE.Color(state.selectedObject.userData.originalColor);
                state.selectedObject.material.emissiveIntensity = 0.1;
                state.selectedObject.material.color.setHex(state.selectedObject.userData.originalColor);
            }

            state.selectedObject = obj;
            // Buat gedung menyala biru
            obj.material.emissive = new THREE.Color(0x0044ff);
            obj.material.emissiveIntensity = 0.5;

            // Kamera fokus ke gedung tersebut (Animasi halus)
            const worldPos = new THREE.Vector3();
            obj.getWorldPosition(worldPos);
            
            gsap.to(controls.target, {
                x: worldPos.x, y: 10, z: worldPos.z,
                duration: 1, ease: "power2.out"
            });

            updateUI(obj.userData); // Update teks di panel kanan
            document.getElementById('detail-panel').classList.add('active'); // Munculkan panel
        }

        // Fungsi Tutup Panel
        function closePanel() {
            document.getElementById('detail-panel').classList.remove('active');
            if (state.selectedObject) {
                // Reset warna gedung
                state.selectedObject.material.emissiveIntensity = 0.1;
                state.selectedObject.material.color.setHex(state.selectedObject.userData.originalColor);
                state.selectedObject = null;
            }
        }

        // Fungsi Update UI Panel Kanan
        // Typing Effect Helper
        let typingTimeout = null;
        function typeText(elementId, text, speed = 20) {
            const el = document.getElementById(elementId);
            if(!el) return;
            
            // Clear previous typing
            if(typingTimeout) clearTimeout(typingTimeout);
            el.innerHTML = "";
            
            let i = 0;
            function type() {
                if (i < text.length) {
                    el.innerHTML += text.charAt(i);
                    i++;
                    typingTimeout = setTimeout(type, speed);
                } else {
                    typingTimeout = null;
                }
            }
            type();
        }

        function updateUI(data) {
            document.getElementById('b-id').innerText = data.id;
            document.getElementById('b-type').innerText = data.type;

            // Hitung nilai statistik (bisa berubah tergantung skenario aktif)
            const polVal = adjustValue(data.pollution, state.activeScenario.traffic ? -30 : 0);
            const enVal = adjustValue(data.energy, state.activeScenario.solar ? -40 : 0);
            const trafVal = adjustValue(data.traffic, state.activeScenario.traffic ? -50 : 0);

            // Update Progress Bar
            animateBar('bar-pol', 'val-pol', polVal, "%");
            animateBar('bar-en', 'val-en', enVal, "% (Usage)");
            animateBar('bar-traf', 'val-traf', trafVal, " Index");
            
            // Security Index (positif: tinggi = baik)
            const baseSecurity = calculateSecurityIndex();
            const isPolice = (data.type || "").toLowerCase().includes('police');
            const secVal = Math.max(0, Math.min(100, isPolice ? Math.min(100, baseSecurity + 10) : baseSecurity));
            animateBarPositive('bar-sec', 'val-sec', secVal, "%");

            // Generate teks AI with typing effect
            const insight = generateAIInsight(data, polVal, enVal);
            typeText('ai-text', insight);
        }

        // Fungsi pembantu hitung nilai (agar tidak < 0 atau > 100)
        function adjustValue(base, modifier) {
            return Math.max(0, Math.min(100, base + modifier));
        }

        // --- TRANSIT OPTIMIZATION SYSTEM ---
        let transitRouteMeshes = [];

        // Helper to get true world position safely
        function getWorldPosition(obj) {
            const vec = new THREE.Vector3();
            obj.getWorldPosition(vec);
            return vec;
        }

        // PATHFINDING HELPER (BFS for Grid)
        function findPathOnGrid(startPos, endPos) {
            const offset = (config.gridSize * config.cellSize) / 2;
            
            // Helper: World to Grid
            const toGrid = (p) => ({
                x: Math.floor((p.x + offset) / config.cellSize),
                z: Math.floor((p.z + offset) / config.cellSize)
            });
            
            // Helper: Grid to World
            const toWorld = (gx, gz) => new THREE.Vector3(
                (gx * config.cellSize) - offset,
                12, // Elevation
                (gz * config.cellSize) - offset
            );

            const startNode = toGrid(startPos);
            const endNode = toGrid(endPos);
            
            // Check bounds
            if (startNode.x < 0 || startNode.x >= config.gridSize || startNode.z < 0 || startNode.z >= config.gridSize) return [startPos, endPos];
            if (endNode.x < 0 || endNode.x >= config.gridSize || endNode.z < 0 || endNode.z >= config.gridSize) return [startPos, endPos];

            // If start/end not on road, find nearest road
            function getNearestRoad(gx, gz) {
                if (cityRoadMap[gx] && cityRoadMap[gx][gz] === 1) return {x: gx, z: gz};
                
                // Search radius 1-3
                for(let r=1; r<=3; r++) {
                    for(let dx=-r; dx<=r; dx++) {
                        for(let dz=-r; dz<=r; dz++) {
                            const nx = gx + dx;
                            const nz = gz + dz;
                            if (nx >= 0 && nx < config.gridSize && nz >= 0 && nz < config.gridSize) {
                                if (cityRoadMap[nx][nz] === 1) return {x: nx, z: nz};
                            }
                        }
                    }
                }
                return {x: gx, z: gz}; // Fallback to original if no road found
            }

            const sNode = getNearestRoad(startNode.x, startNode.z);
            const eNode = getNearestRoad(endNode.x, endNode.z);

            // BFS
            const queue = [];
            queue.push([sNode]);
            const visited = new Set();
            visited.add(`${sNode.x},${sNode.z}`);
            
            // Limit iterations to prevent freeze
            let iterations = 0;
            const maxIterations = 4000;

            while(queue.length > 0) {
                iterations++;
                if (iterations > maxIterations) break;

                const path = queue.shift();
                const curr = path[path.length - 1];

                if (curr.x === eNode.x && curr.z === eNode.z) {
                    // Found! Convert to world points
                    // Optimize: Don't need every single point, just corners? 
                    // For TubeGeometry, having points every block is actually fine and makes it follow grid perfectly.
                    // But we can simplify straight lines.
                    
                    const worldPath = [];
                    // Add true start
                    worldPath.push(new THREE.Vector3(startPos.x, 12, startPos.z));
                    
                    // Add grid path
                    path.forEach(p => worldPath.push(toWorld(p.x, p.z)));
                    
                    // Add true end
                    worldPath.push(new THREE.Vector3(endPos.x, 12, endPos.z));
                    
                    return worldPath;
                }

                const dirs = [
                    {x:0, z:1}, {x:0, z:-1}, {x:1, z:0}, {x:-1, z:0}
                ];

                // Prioritize direction towards target? (A* heuristic)
                // Simple sort of neighbors by distance to end
                dirs.sort((a, b) => {
                    const da = Math.abs((curr.x + a.x) - eNode.x) + Math.abs((curr.z + a.z) - eNode.z);
                    const db = Math.abs((curr.x + b.x) - eNode.x) + Math.abs((curr.z + b.z) - eNode.z);
                    return da - db;
                });

                for(const d of dirs) {
                    const nx = curr.x + d.x;
                    const nz = curr.z + d.z;
                    const key = `${nx},${nz}`;

                    if (nx >= 0 && nx < config.gridSize && nz >= 0 && nz < config.gridSize) {
                        if (!visited.has(key) && cityRoadMap[nx][nz] === 1) {
                            visited.add(key);
                            const newPath = [...path, {x: nx, z: nz}];
                            queue.push(newPath);
                        }
                    }
                }
            }

            // Fallback: Manhattan L-Shape if no path found
            return [
                new THREE.Vector3(startPos.x, 12, startPos.z),
                new THREE.Vector3(endPos.x, 12, startPos.z), // Corner 1
                new THREE.Vector3(endPos.x, 12, endPos.z)
            ];
        }

        function generateTransitRoutes() {
            // 1. Reset Visualization
            transitRouteMeshes.forEach(mesh => scene.remove(mesh));
            transitRouteMeshes = [];
            
            const mode = document.getElementById('transit-mode').value;
            const btn = document.getElementById('btn-generate-routes');
            const statsDiv = document.getElementById('route-stats');
            
            const originalText = btn.innerHTML;
            btn.innerHTML = "ANALYZING...";
            btn.disabled = true;
            
            // Allow UI to update before heavy calculation
            setTimeout(() => {
                // 2. Identify High Traffic Nodes
                // Filter buildings with high traffic
                // Make sure to include custom buildings (stadium, etc) which are also in 'buildings' array
                const highTrafficNodes = buildings
                    .filter(b => (b.userData?.traffic || 0) > 50)
                    .sort((a, b) => (b.userData?.traffic || 0) - (a.userData?.traffic || 0))
                    .slice(0, 15); // Top 15 hubs

                if (highTrafficNodes.length < 2) {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    statsDiv.style.display = "block";
                    statsDiv.innerHTML = "Insufficient data for optimization.";
                    return;
                }

                // 3. Pathfinding (Greedy TSP-like)
                // Connect nodes in a logical sequence
                
                const orderedNodes = [];
                const visited = new Set();
                
                // Start with the busiest
                let current = highTrafficNodes[0];
                let currentPos = getWorldPosition(current);
                
                orderedNodes.push(current);
                visited.add(current.uuid);
                
                while(orderedNodes.length < highTrafficNodes.length) {
                    let nearest = null;
                    let minDist = Infinity;
                    let nearestPos = null;
                    
                    for(const node of highTrafficNodes) {
                        if(visited.has(node.uuid)) continue;
                        
                        const nodePos = getWorldPosition(node);
                        
                        // Distance calculation
                        const d = currentPos.distanceTo(nodePos);
                        if(d < minDist) {
                            minDist = d;
                            nearest = node;
                            nearestPos = nodePos;
                        }
                    }
                    
                    if(nearest) {
                        visited.add(nearest.uuid);
                        orderedNodes.push(nearest);
                        current = nearest;
                        currentPos = nearestPos;
                    } else {
                        break;
                    }
                }
                
                // Close the loop
                orderedNodes.push(orderedNodes[0]);

                // Generate path points
                const fullPath = [];
                
                // Use new Pathfinder
                for(let i=0; i<orderedNodes.length-1; i++) {
                    const p1 = getWorldPosition(orderedNodes[i]);
                    const p2 = getWorldPosition(orderedNodes[i+1]);
                    const segmentPoints = findPathOnGrid(p1, p2);
                    // Add points to fullPath (avoid duplicates if possible)
                    segmentPoints.forEach(p => fullPath.push(p));
                }
                // Close loop
                const pStart = getWorldPosition(orderedNodes[orderedNodes.length-1]);
                const pEnd = getWorldPosition(orderedNodes[0]);
                const lastSegment = findPathOnGrid(pStart, pEnd);
                lastSegment.forEach(p => fullPath.push(p));

                // 4. Visualization
                // Create a smooth curve from the path
                const curve = new THREE.CatmullRomCurve3(fullPath);
                curve.tension = 0.05; // Very tight to stick to grid corners
                
                // --- UPGRADE: Use TubeGeometry for thick lines ---
                const tubeRadius = 1.2; // Much thicker than line width
                const tubeSegments = fullPath.length * 12;
                const tubeRadialSegments = 8;
                const closedTube = false;
                
                const tubeGeo = new THREE.TubeGeometry(curve, tubeSegments, tubeRadius, tubeRadialSegments, closedTube);
                
                // Color based on mode
                let routeColor = 0x00f2ff; // Cyan (Bus)
                if (mode === 'rail') routeColor = 0x00ff41; // Green
                if (mode === 'metro') routeColor = 0xff0055; // Red

                // Neon Glow Material
                const material = new THREE.MeshStandardMaterial({ 
                    color: routeColor,
                    emissive: routeColor,
                    emissiveIntensity: 2.0, // High glow
                    roughness: 0.2,
                    metalness: 0.8,
                    transparent: true,
                    opacity: 0.85
                });
                
                const routeMesh = new THREE.Mesh(tubeGeo, material);
                // Lift slightly higher to avoid z-fighting with buildings/roads if close
                routeMesh.position.y = 0.5; 
                scene.add(routeMesh);
                transitRouteMeshes.push(routeMesh);
                
                // Add Inner Core (White/Bright center for "laser" effect)
                const coreRadius = 0.4;
                const coreGeo = new THREE.TubeGeometry(curve, tubeSegments, coreRadius, 6, closedTube);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const coreMesh = new THREE.Mesh(coreGeo, coreMat);
                coreMesh.position.y = 0.5;
                scene.add(coreMesh);
                transitRouteMeshes.push(coreMesh);
                
                // Add Stations (Visual markers at nodes)
                // --- UPGRADE: Larger, more visible stations ---
                const stationGeo = new THREE.CylinderGeometry(5, 5, 2, 8); // Bigger
                const stationMat = new THREE.MeshStandardMaterial({ 
                    color: routeColor, 
                    emissive: routeColor,
                    emissiveIntensity: 1.5,
                    transparent: true, 
                    opacity: 0.9,
                    wireframe: false // Solid for better visibility
                });
                
                // Add ring around station
                const ringGeo = new THREE.TorusGeometry(8, 0.8, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

                orderedNodes.forEach((node, index) => {
                    // Don't duplicate start/end marker
                    if(index === orderedNodes.length - 1) return;
                    
                    const pos = getWorldPosition(node);

                    const stationGroup = new THREE.Group();
                    stationGroup.position.set(pos.x, 12, pos.z);

                    const station = new THREE.Mesh(stationGeo, stationMat);
                    stationGroup.add(station);
                    
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    stationGroup.add(ring);

                    // Rotate slowly
                    stationGroup.userData = { rotate: true, axis: 'y', speed: 0.5 };
                    scene.add(stationGroup);
                    transitRouteMeshes.push(stationGroup);
                    
                    // Add vertical connector beam (Laser style)
                    const beamHeight = 200; // Go up into sky
                    const beamGeo = new THREE.CylinderGeometry(0.5, 0.5, beamHeight, 8);
                    beamGeo.translate(0, beamHeight/2, 0); // Pivot at bottom
                    
                    const beamMat = new THREE.MeshBasicMaterial({ 
                        color: routeColor, 
                        transparent: true, 
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const beam = new THREE.Mesh(beamGeo, beamMat);
                    beam.position.set(pos.x, 0, pos.z);
                    scene.add(beam);
                    transitRouteMeshes.push(beam);
                });

                // 5. Update UI
                btn.innerHTML = "GENERATE ROUTES";
                btn.disabled = false;
                
                statsDiv.style.display = "block";
                
                // Real Coverage Calculation
                let coveredBuildings = 0;
                const coverageRadius = 150; // Units
                
                buildings.forEach(b => {
                    if(!b.visible) return;
                    const bPos = getWorldPosition(b);
                    for(const node of orderedNodes) {
                        const nodePos = getWorldPosition(node);
                        if(bPos.distanceTo(nodePos) < coverageRadius) {
                            coveredBuildings++;
                            break; // Covered by at least one station
                        }
                    }
                });

                const coveragePct = Math.floor((coveredBuildings / buildings.length) * 100);
                const efficiency = Math.floor(coveragePct * 0.8 + Math.random() * 10);
                
                statsDiv.innerHTML = `
                    <div style="color:${mode === 'metro' ? '#ff0055' : (mode === 'rail' ? '#00ff41' : '#00f2ff')}">
                    <strong>${mode.toUpperCase()} OPTIMIZED</strong><br>
                    ‚Ä¢ Stations: ${orderedNodes.length - 1}<br>
                    ‚Ä¢ Traffic Load: ${Math.floor(Math.random() * 2000 + 5000)} pax/hr<br>
                    ‚Ä¢ Efficiency: <span style="color:#fff">+${efficiency}%</span><br>
                    ‚Ä¢ City Coverage: <span style="color:#fff">${coveragePct}%</span>
                    </div>
                `;
                
                // Camera flyover
                // GSAP animation to view the route
                if (window.gsap) {
                    gsap.to(camera.position, {
                        x: current.position.x + 100,
                        y: 200,
                        z: current.position.z + 100,
                        duration: 2,
                        ease: "power2.inOut"
                    });
                    if (window.controls) {
                        gsap.to(controls.target, {
                            x: current.position.x,
                            y: 0,
                            z: current.position.z,
                            duration: 2,
                            ease: "power2.inOut"
                        });
                    }
                }
                
            }, 500); // Simulated delay
        }

        // Fungsi Animasi Progress Bar
        function animateBar(barId, textId, val, suffix) {
            const bar = document.getElementById(barId);
            bar.style.width = val + '%';
            // Ubah warna bar tergantung nilai (Merah/Kuning/Hijau)
            if (val > 70) bar.style.background = 'var(--danger)';
            else if (val > 40) bar.style.background = 'var(--warning)';
            else bar.style.background = 'var(--success)';
            document.getElementById(textId).innerText = val + suffix;
        }
        
        // Versi positif: nilai tinggi = hijau (untuk indeks keamanan)
        function animateBarPositive(barId, textId, val, suffix) {
            const bar = document.getElementById(barId);
            bar.style.width = val + '%';
            if (val > 70) bar.style.background = 'var(--success)';
            else if (val > 40) bar.style.background = 'var(--warning)';
            else bar.style.background = 'var(--danger)';
            document.getElementById(textId).innerText = val + suffix;
        }

        // Logika AI Insight (Teks otomatis)
        function generateAIInsight(data, pol, en) {
            if (state.activeScenario.solar && en < 40) return "Solar efficiency maximized. Grid reliance reduced significantly.";
            if (state.activeScenario.green && pol < 50) return "Green infrastructure successfully scrubbing particulate matter.";
            if (pol > 80) return "CRITICAL: High emissions. Suggest applying Green Infrastructure filters.";
            if (en > 80) return "Inefficient insulation detected. Retrofit with Solar panels recommended.";
            return "Structure operating within nominal parameters.";
        }

        // --- ENERGY GRID SYSTEM ---
        function openEnergyGridPanel() {
            closeAllPanels('energy-panel');
            document.getElementById('energy-panel').style.display = 'block';
            updateEnergyUI();
        }

        function closeEnergyGridPanel() {
            document.getElementById('energy-panel').style.display = 'none';
        }

        function updateEnergyUI() {
            // Update Solar Count
            const solarBtn = document.getElementById('btn-solar-roof');
            if (greenState.solar.active) {
                solarBtn.classList.add('active');
                document.getElementById('count-solar').innerHTML = greenState.solar.stats.count + " Arrays";
            } else {
                solarBtn.classList.remove('active');
                document.getElementById('count-solar').innerHTML = "0 Units";
            }

            // Update Wind
            const windBtn = document.getElementById('btn-wind-farm');
            if (energyState.wind.active) {
                windBtn.classList.add('active');
                document.getElementById('count-wind').innerHTML = energyState.wind.meshes.length + " Turbines";
            } else {
                windBtn.classList.remove('active');
                document.getElementById('count-wind').innerHTML = "0 Units";
            }

            // Update Battery
            const battBtn = document.getElementById('btn-battery');
            if (energyState.battery.active) {
                battBtn.classList.add('active');
                document.getElementById('count-battery').innerHTML = energyState.battery.meshes.length + " Banks";
            } else {
                battBtn.classList.remove('active');
                document.getElementById('count-battery').innerHTML = "0 Units";
            }

            // Update Storage Meter
            const storageCap = energyState.battery.active ? energyState.battery.capacity : 0;
            const maxStorage = 50000; // Arbitrary max
            const storagePct = Math.min(100, (storageCap / maxStorage) * 100);
            document.getElementById('meter-storage').style.width = storagePct + "%";
            document.getElementById('text-storage').innerHTML = (storageCap / 1000).toFixed(1) + " MWh";

            // Update Balance
            // Calculate Total Demand
            let totalDemand = 0;
            buildings.forEach(b => {
                if (b.userData && b.userData.energy) {
                    totalDemand += b.userData.energy;
                }
            });

            // Calculate Total Gen
            let totalGen = 0;
            if (greenState.solar.active) totalGen += greenState.solar.stats.energy; // Solar
            if (energyState.wind.active) totalGen += energyState.wind.capacity; // Wind

            // Normalize for visual bar (Max 50MW = 50000kW)
            const maxLoad = 80000; 
            const demandPct = Math.min(50, (totalDemand / maxLoad) * 50);
            const genPct = Math.min(50, (totalGen / maxLoad) * 50);

            document.getElementById('load-fill').style.width = demandPct + "%";
            document.getElementById('gen-fill').style.width = genPct + "%";

            const balanceText = document.getElementById('balance-text');
            const net = totalGen - totalDemand;
            
            if (net > 0) {
                balanceText.innerHTML = `SURPLUS: +${(net/1000).toFixed(1)} MW (Charging Storage)`;
                balanceText.style.color = "#2ecc71";
            } else {
                // Check if battery can cover
                if (energyState.battery.active && energyState.battery.capacity > Math.abs(net)*0.1) { // 0.1 hour buffer
                     balanceText.innerHTML = `DEFICIT: ${(net/1000).toFixed(1)} MW (Discharging Battery)`;
                     balanceText.style.color = "#f1c40f";
                } else {
                     balanceText.innerHTML = `GRID UNSTABLE: ${(net/1000).toFixed(1)} MW`;
                     balanceText.style.color = "#e74c3c";
                }
            }
        }

        // Hook into existing solar deploy to update UI
        const originalDeployGreen = deployGreenTech;
        deployGreenTech = function(type) {
            originalDeployGreen(type);
            updateEnergyUI();
        }

        function deployWindFarm() {
            energyState.wind.active = !energyState.wind.active;
            
            if (energyState.wind.active) {
                // Deploy Wind Turbines on Sea or Hills
                // Let's place them on the sea area (x < 0)
                const turbineCount = 8;
                const capacityPerTurbine = 2500; // 2.5 MW
                
                for(let i=0; i<turbineCount; i++) {
                    const group = new THREE.Group();
                    
                    // Pole
                    const pole = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 1, 30),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    pole.position.y = 15;
                    group.add(pole);
                    
                    // Nacelle
                    const nacelle = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 2, 2),
                        new THREE.MeshStandardMaterial({ color: 0x95a5a6 })
                    );
                    nacelle.position.y = 30;
                    group.add(nacelle);
                    
                    // Blades
                    const bladeGeo = new THREE.BoxGeometry(1, 18, 0.5);
                    bladeGeo.translate(0, 9, 0); // Pivot at base
                    const bladeMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
                    
                    const blades = new THREE.Group();
                    blades.position.set(0, 30, 1.2);
                    
                    for(let b=0; b<3; b++) {
                        const blade = new THREE.Mesh(bladeGeo, bladeMat);
                        blade.rotation.z = (b * Math.PI * 2) / 3;
                        blades.add(blade);
                    }
                    
                    // Animation data
                    blades.userData = { rotate: true, axis: 'z', speed: 2.0 + Math.random() * 1.0 };
                    group.add(blades);
                    
                    // Position in Sea (Far West area)
                    // City is roughly -200 to +200. Sea starts around -200.
                    // Place further out: -300 to -500
                    const tx = -300 - (Math.random() * 200);
                    const tz = (Math.random() * 400) - 200; // Spread along coast
                    group.position.set(tx, 0, tz);
                    group.rotation.y = Math.PI / 2; // Face wind
                    
                    scene.add(group);
                    energyState.wind.meshes.push(group);
                    
                    // Add to animation loop array
                    transitRouteMeshes.push(blades); // Reuse this array for rotation updates or add new one
                }
                
                energyState.wind.capacity = turbineCount * capacityPerTurbine;
                
            } else {
                // Remove
                energyState.wind.meshes.forEach(m => scene.remove(m));
                energyState.wind.meshes = [];
                energyState.wind.capacity = 0;
            }
            updateEnergyUI();
        }

        function deployBatteries() {
            energyState.battery.active = !energyState.battery.active;
            
            if (energyState.battery.active) {
                // Place Battery Banks near Substations or Industrial
                // We'll place a few large containers
                const count = 4;
                const capPerUnit = 5000; // 5 MWh
                
                for(let i=0; i<count; i++) {
                    const group = new THREE.Group();
                    
                    const battGeo = new THREE.BoxGeometry(6, 3, 3);
                    const battMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                    const batt = new THREE.Mesh(battGeo, battMat);
                    batt.position.y = 1.5;
                    group.add(batt);
                    
                    // Decal
                    const decal = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 2),
                        new THREE.MeshBasicMaterial({ color: 0x2ecc71, side: THREE.DoubleSide })
                    );
                    decal.position.set(0, 3.1, 0);
                    decal.rotation.x = -Math.PI/2;
                    group.add(decal);
                    
                    // Find a clear spot? Just place on edge for now
                    const tx = 50 + (i * 10);
                    const tz = 50;
                    group.position.set(tx, 0, tz);
                    
                    scene.add(group);
                    energyState.battery.meshes.push(group);
                }
                
                energyState.battery.capacity = count * capPerUnit;
                
            } else {
                energyState.battery.meshes.forEach(m => scene.remove(m));
                energyState.battery.meshes = [];
                energyState.battery.capacity = 0;
            }
            updateEnergyUI();
        }

        // --- GREEN INFRASTRUCTURE SYSTEM ---
        function closeAllPanels(exceptId) {
            const panels = [
                { id: 'stats-panel', btnId: 'toggle-stats', type: 'class-hidden' },
                { id: 'green-panel', btnId: 'btn-green', type: 'display' },
                { id: 'energy-panel', btnId: null, type: 'display' },
                { id: 'transit-panel', btnId: 'toggle-transit', type: 'display' },
                { id: 'controls-help', btnId: 'toggle-help', type: 'class-hidden' } // controls-help uses .hidden in original, wait, let's check
            ];

            panels.forEach(p => {
                if (p.id === exceptId) return;
                const el = document.getElementById(p.id);
                if (!el) return;

                // Close logic
                if (p.type === 'class-hidden') {
                    if (!el.classList.contains('hidden')) el.classList.add('hidden');
                } else {
                    el.style.display = 'none';
                }

                // Button reset logic
                if (p.btnId) {
                    const btn = document.getElementById(p.btnId);
                    if (btn) {
                        if (p.id === 'green-panel') {
                            // For green panel (scenario), we might want to keep the state or deactivate it
                            // If we close the panel, we should probably deactivate the scenario visualization? 
                            // Or just close the panel but keep visualization?
                            // User request is about "exclusive panel logic".
                            // Let's just close the panel UI.
                        } else {
                             btn.style.display = 'block';
                        }
                    }
                }
            });
        }

        function toggleGreenPanel() {
            closeAllPanels('green-panel');
            const panel = document.getElementById('green-panel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
            }
        }
        
        function updateGreenStats() {
            const statsDiv = document.getElementById('green-stats');
            
            let totalEnergy = 0;
            let totalHeat = 0;
            let totalAir = 0;
            let anyActive = false;
            
            if (greenState.solar.active) totalEnergy = greenState.solar.stats.energy;
            if (greenState.garden.active) totalHeat = greenState.garden.stats.heat;
            if (greenState.vertical.active) totalAir = greenState.vertical.stats.air;
            
            if (!greenState.solar.active && !greenState.garden.active && !greenState.vertical.active) {
                  statsDiv.style.display = 'none';
                  document.getElementById('grid-monitor').style.display = 'none';
                  
                  // Reset Visualization Colors
                  buildings.forEach(b => {
                     if (b.material && b.userData.originalColor) {
                         b.material.color.setHex(b.userData.originalColor);
                     }
                  });
                  return;
              }
             
             statsDiv.style.display = 'block';
             let html = "";
             if (greenState.solar.active) html += `<div>‚ö° Energy: +${totalEnergy} kWh</div>`;
             if (greenState.garden.active) html += `<div>üå°Ô∏è Heat Reduction: -${totalHeat}¬∞C</div>`;
             if (greenState.vertical.active) html += `<div>üçÉ Air Quality: +${totalAir}%</div>`;
             
             statsDiv.innerHTML = html;

             // UPDATE GRID MONITOR
             if (greenState.solar.active) {
                 const monitor = document.getElementById('grid-monitor');
                 monitor.style.display = 'block';
                 
                 // Calculate City Total Demand
                 let totalDemand = 0;
                 buildings.forEach(b => {
                     if (b.userData && b.userData.energy) {
                         totalDemand += b.userData.energy;
                     }
                 });
                 // Convert kW to MW
                 const demandMW = (totalDemand / 1000).toFixed(1);
                 const renewableMW = (totalEnergy / 1000).toFixed(2); // totalEnergy is in kWh (which is energy, but let's assume power kW for sim)
                 
                 const percent = Math.min(100, (totalEnergy / totalDemand) * 100);
                 
                 document.getElementById('grid-demand').innerHTML = `${demandMW} MW`;
                 document.getElementById('bar-demand').style.width = '100%';
                 
                 document.getElementById('grid-renewable').innerHTML = `${renewableMW} MW`;
                 document.getElementById('bar-renewable').style.width = `${percent}%`;
                 
                 const statusEl = document.getElementById('grid-status');
                 if (percent > 20) {
                     statusEl.innerHTML = "SUSTAINABLE";
                     statusEl.style.color = "#2ecc71";
                 } else if (percent > 5) {
                     statusEl.innerHTML = "TRANSITIONING";
                     statusEl.style.color = "#f1c40f";
                 } else {
                     statusEl.innerHTML = "FOSSIL DEPENDENT";
                     statusEl.style.color = "#e74c3c";
                 }

                 // VISUALIZATION: Energy Heatmap
                 // Only if not already applied
                 buildings.forEach(b => {
                     if (b.userData && b.userData.energy) {
                         // Color based on consumption
                         // High energy = Red, Low = Yellow/Green
                         // Normalize: Max ~500?
                         const val = Math.min(1, b.userData.energy / 500);
                         const color = new THREE.Color();
                         // Lerp from Green to Red
                         color.setHSL(0.3 - (val * 0.3), 1.0, 0.5); // Green(0.3) to Red(0.0)
                         
                         // If it has solar, make it Blue/Cyan
                         // How do we know if THIS building has solar?
                         // We can check position against solar meshes? Or just mark userData when deploying
                         // Simplified: We didn't mark userData.
                         
                         b.material.color.copy(color);
                     }
                 });
             } else {
                 document.getElementById('grid-monitor').style.display = 'none';
                 // Reset colors
                 buildings.forEach(b => {
                    if (b.material && b.userData.originalColor) {
                        b.material.color.setHex(b.userData.originalColor);
                    }
                 });
             }
         }

        function deployGreenTech(type) {
            let btn = document.getElementById('opt-' + type);
            // Fallback for new Energy Panel buttons
            if (!btn && type === 'solar') btn = document.getElementById('btn-solar-roof');
            
            // If still no button (e.g. called programmatically or UI changed), just warn and proceed if possible
            if (!btn) {
                console.warn("Button not found for type:", type);
                // We can still toggle state, but can't update class
            }

            const state = greenState[type];
            
            // Toggle State
            state.active = !state.active;
            
            if (state.active) {
                if (btn) btn.classList.add('active');
                
                // If already generated, just show them
                if (state.meshes.length > 0) {
                    state.meshes.forEach(m => { m.visible = true; });
                    updateGreenStats();
                    return;
                }
                
                // Generate new meshes
                const candidates = buildings.filter(b => b.userData && !b.userData.type.includes("Stadium"));

                if (type === 'solar') {
                    let count = 0;
                    candidates.forEach(b => {
                        if (Math.random() > 0.6) return; 
                        
                        b.geometry.computeBoundingBox();
                        const size = new THREE.Vector3();
                        b.geometry.boundingBox.getSize(size);
                        
                        const panelW = size.x * 0.8;
                        const panelD = size.z * 0.8;
                        const panelGeo = new THREE.PlaneGeometry(panelW, panelD);
                        const panelMat = new THREE.MeshBasicMaterial({ 
                            color: 0x0044ff, 
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.6,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const solar = new THREE.Mesh(panelGeo, panelMat);
                        solar.rotation.x = -Math.PI / 2;
                        
                        const topY = b.geometry.boundingBox.max.y;
                        const worldPos = getWorldPosition(b);
                        
                        solar.position.set(worldPos.x, topY + 0.5, worldPos.z);
                        scene.add(solar);
                        state.meshes.push(solar);
                        
                        const glowGeo = new THREE.BoxGeometry(panelW, 0.5, panelD);
                        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true, transparent: true, opacity: 0.3 });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        glow.position.copy(solar.position);
                        scene.add(glow);
                        state.meshes.push(glow);
                        
                        count++;
                    });
                    state.stats.count = count;
                    state.stats.energy = count * 120;
                
                } else if (type === 'garden') {
                    let count = 0;
                    candidates.forEach(b => {
                        if (Math.random() > 0.7) return;
                        
                        b.geometry.computeBoundingBox();
                        const topY = b.geometry.boundingBox.max.y;
                        const size = new THREE.Vector3();
                        b.geometry.boundingBox.getSize(size);
                        const worldPos = getWorldPosition(b);
                        
                        const gardenGeo = new THREE.BoxGeometry(size.x * 0.9, 1, size.z * 0.9);
                        const gardenMat = new THREE.MeshStandardMaterial({ 
                            color: 0x2ecc71, 
                            roughness: 1,
                            transparent: true,
                            opacity: 0.8
                        });
                        const garden = new THREE.Mesh(gardenGeo, gardenMat);
                        garden.position.set(worldPos.x, topY, worldPos.z);
                        scene.add(garden);
                        state.meshes.push(garden);
                        
                        for(let i=0; i<5; i++) {
                            const treeGeo = new THREE.DodecahedronGeometry(1.5, 0);
                            const treeMat = new THREE.MeshStandardMaterial({ color: 0x27ae60 });
                            const tree = new THREE.Mesh(treeGeo, treeMat);
                            tree.position.set(
                                worldPos.x + (Math.random()-0.5)*size.x*0.6,
                                topY + 1.5,
                                worldPos.z + (Math.random()-0.5)*size.z*0.6
                            );
                            scene.add(tree);
                            state.meshes.push(tree);
                        }
                        count++;
                    });
                    state.stats.count = count;
                    state.stats.heat = Math.floor(count * 0.5);

                } else if (type === 'vertical') {
                    let count = 0;
                    candidates.forEach(b => {
                        if (Math.random() > 0.75) return;
                        
                        b.geometry.computeBoundingBox();
                        const size = new THREE.Vector3();
                        b.geometry.boundingBox.getSize(size);
                        const height = size.y;
                        const worldPos = getWorldPosition(b);
                        
                        const vineGeo = new THREE.CylinderGeometry(size.x * 0.6, size.x * 0.6, height * 0.8, 4, 8, true);
                        const vineMat = new THREE.MeshBasicMaterial({ 
                            color: 0x00ff00, 
                            wireframe: true, 
                            transparent: true, 
                            opacity: 0.4 
                        });
                        const vines = new THREE.Mesh(vineGeo, vineMat);
                        vines.position.set(worldPos.x, height/2, worldPos.z);
                        scene.add(vines);
                        state.meshes.push(vines);
                        count++;
                    });
                    state.stats.count = count;
                    state.stats.air = count;
                }
                updateGreenStats();

            } else {
                // Deactivate
                if (btn) btn.classList.remove('active');
                state.meshes.forEach(m => { m.visible = false; });
                updateGreenStats();
            }
        }

        // Logika Tombol Skenario (Solar, Traffic, Green)
        window.toggleScenario = function (type) {
            state.activeScenario[type] = !state.activeScenario[type]; // Toggle true/false buttonnya
            document.getElementById('btn-' + type).classList.toggle('active'); // Ubah warna tombol

            // If Green is clicked, toggle the new panel
            if (type === 'green') {
                toggleGreenPanel();
            }

            // Efek "Solar": ubah gedung jadi biru untuk menandakan panel surya
            if (type === 'solar') {
                buildings.forEach(b => {
                    const original = b.userData.originalColor;
                    if (state.activeScenario.solar) b.material.color.setHex(config.solarColor);
                    else b.material.color.setHex(original);
                });
            }
            // Efek "Traffic": mobil hilang
            if (type === 'traffic') {
                cars.forEach(car => car.visible = !state.activeScenario.traffic);
            }
            // Efek "Green": ubah beberapa bangunan jadi hijau
            if (type === 'green') {
                buildings.forEach(b => {
                    const original = b.userData.originalColor;
                    if (state.activeScenario.green && Math.random() > 0.5) b.material.color.setHex(config.greenColor);
                    else if (!state.activeScenario.solar) b.material.color.setHex(original);
                });
            }
            // Update tampilan panel jika ada gedung terpilih
            if (state.selectedObject) updateUI(state.selectedObject.userData);
        };

        // Function to toggle controls help panel
        window.toggleControlsHelp = function () {
            closeAllPanels('controls-help');
            const helpPanel = document.getElementById('controls-help');
            const toggleBtn = document.getElementById('toggle-help');
            
            // Check if it was already open (since closeAllPanels might have closed it if we didn't handle the 'except' logic perfectly for class-hidden, 
            // but closeAllPanels logic for 'class-hidden' says: if !hidden -> add hidden.
            // So if we call closeAllPanels('controls-help'), it ignores controls-help.
            // So we can just toggle safely.
            
            helpPanel.classList.toggle('hidden');
            if (helpPanel.classList.contains('hidden')) {
                toggleBtn.style.display = 'block';
            } else {
                toggleBtn.style.display = 'none';
            }
        };

        // Function to toggle Day/Night cycle manually
        window.toggleDayNight = function () {
            if (lastDayFactor > 0.5) {
                timeOfDay = 0.5; // Switch to Midnight
            } else {
                timeOfDay = 0.0; // Switch to Noon
            }
            // Trigger update immediately
            updateDayNightCycle(0);
        };

        // Function to toggle transit panel
        window.toggleTransitPanel = function () {
            closeAllPanels('transit-panel');
            const panel = document.getElementById('transit-panel');
            const toggleBtn = document.getElementById('toggle-transit');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggleBtn.style.display = 'none';
            } else {
                panel.style.display = 'none';
                toggleBtn.style.display = 'block';
            }
        };

        // Function to toggle stats panel visibility
        window.toggleStatsPanel = function () {
            closeAllPanels('stats-panel');
            const panel = document.getElementById('stats-panel');
            const toggleBtn = document.getElementById('toggle-stats');

            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                toggleBtn.style.display = 'none';
            } else {
                panel.classList.add('hidden');
                toggleBtn.style.display = 'block';
            }
        };

        // Function to calculate city statistics based on building energy efficiency and pollution
        function calculateCityStats() {
            let totalEnergy = 0;
            let energyCount = 0;
            buildings.forEach(b => {
                if (b.userData && b.userData.energy !== undefined) {
                    totalEnergy += b.userData.energy;
                    energyCount++;
                }
            });
            const avgEnergy = energyCount > 0 ? totalEnergy / energyCount : 50;
            let energyEfficiency = Math.max(0, Math.min(100, 100 - (avgEnergy / 20)));
            let greenBonus = 0;
            if (greenState.solar.active) {
                const solarGen = (greenState.solar.stats && greenState.solar.stats.energy) ? greenState.solar.stats.energy : 0;
                if (totalEnergy > 0) {
                    const ratio = solarGen / totalEnergy;
                    greenBonus += Math.min(30, ratio * 100); 
                }
            }
            if (energyState.wind.active) {
                 const windGen = energyState.wind.capacity || 0;
                 if (totalEnergy > 0) {
                     const ratio = windGen / totalEnergy;
                     greenBonus += Math.min(20, ratio * 50);
                 }
            }
            if (energyState.battery.active) {
                greenBonus += 5;
            }
            energyEfficiency = Math.min(100, energyEfficiency + greenBonus);
            let totalPollution = 0;
            let pollutionCount = 0;
            buildings.forEach(b => {
                if (b.userData && b.userData.pollution !== undefined) {
                    totalPollution += b.userData.pollution;
                    pollutionCount++;
                }
            });
            const avgPollution = pollutionCount > 0 ? totalPollution / pollutionCount : 50;
            let pollutionScore = Math.max(0, Math.min(100, 100 - avgPollution));
            let pollutionBonus = 0;
            if (state.activeScenario.traffic) {
                pollutionBonus += 15;
            }
            if (greenState.garden.active) {
                const gardens = (greenState.garden.stats && greenState.garden.stats.count) ? greenState.garden.stats.count : 0;
                pollutionBonus += Math.min(15, gardens * 0.1);
            }
            if (greenState.vertical.active) {
                 const forests = (greenState.vertical.stats && greenState.vertical.stats.count) ? greenState.vertical.stats.count : 0;
                 pollutionBonus += Math.min(20, forests * 0.2);
            }
            if (energyState.wind.active) {
                pollutionBonus += 10;
            }
            pollutionScore = Math.min(100, pollutionScore + pollutionBonus);
            const energyWeight = 0.50;
            const pollutionWeight = 0.50;
            const legacyTotal = Math.round((energyEfficiency * energyWeight) + (pollutionScore * pollutionWeight));
            let gdsResult = null;
            try {
                gdsResult = calculateGDSStats({
                    energyEfficiency,
                    pollutionScore,
                    totalEnergy
                });
            } catch (e) {
                gdsResult = null;
            }
            if (gdsResult && Number.isFinite(gdsResult.total)) {
                return {
                    energy: Math.round(energyEfficiency),
                    pollution: Math.round(pollutionScore),
                    total: Math.max(0, Math.min(100, Math.round(gdsResult.total))),
                    gds: gdsResult.gds
                };
            } else {
                return {
                    energy: Math.round(energyEfficiency),
                    pollution: Math.round(pollutionScore),
                    total: legacyTotal
                };
            }
        }

        // Indeks Keamanan Kota: berdasarkan kepadatan kantor polisi terhadap total grid
        function calculateSecurityIndex() {
            const totalCells = config.gridSize * config.gridSize;
            const count = policeStations.length;
            // Skala: setiap kantor polisi ‚âà + (10000 / totalCells) poin
            const scaled = (count / totalCells) * 10000;
            return Math.max(0, Math.min(100, Math.round(scaled)));
        }

        function calculateHealthIndex() {
            let hospitals = 0;
            buildings.forEach(b => {
                const t = (b.userData && b.userData.type) ? b.userData.type.toLowerCase() : "";
                if (t.includes("hospital")) hospitals++;
            });
            let totalPollution = 0;
            let pollutionCount = 0;
            buildings.forEach(b => {
                if (b.userData && b.userData.pollution !== undefined) {
                    totalPollution += b.userData.pollution;
                    pollutionCount++;
                }
            });
            const avgPollution = pollutionCount > 0 ? totalPollution / pollutionCount : 50;
            const populationProxy = Math.max(1, buildings.length * 35);
            const hospitalsPer50k = populationProxy > 0 ? hospitals / (populationProxy / 50000) : 0;
            let base = Math.min(100, hospitalsPer50k * 100);
            const pollutionImpact = Math.min(20, avgPollution * 0.2);
            if (greenState.garden.active) base += 5;
            return Math.max(0, Math.min(100, Math.round(base - pollutionImpact)));
        }

        function calculateEconomyIndex() {
            let totalJobs = 0;
            let commercialCount = 0;
            buildings.forEach(b => {
                const type = (b.userData && b.userData.type) ? b.userData.type : "";
                if (type.includes("Office") || type.includes("Corporate") || type.includes("Hotel") || type.includes("Retail") || type.includes("Shops")) {
                    totalJobs += 80;
                    commercialCount++;
                }
                if (type.includes("HQ")) totalJobs += 120;
            });
            const populationProxy = Math.max(1, buildings.length * 35);
            const jobsRatio = populationProxy > 0 ? totalJobs / populationProxy : 0;
            let base = Math.min(100, jobsRatio * 100);
            const commercialBoost = Math.min(10, (commercialCount / Math.max(1, buildings.length)) * 200);
            if (energyState.wind.active) base += 3;
            if (energyState.battery.active) base += 2;
            base += commercialBoost;
            return Math.max(0, Math.min(100, Math.round(base)));
        }

        function calculateGDSStats(base) {
            const energyEff = Math.max(0, Math.min(100, base.energyEfficiency || 0));
            const pollutionClean = Math.max(0, Math.min(100, base.pollutionScore || 0));
            const environmentalPerformance = Math.round((energyEff + pollutionClean) / 2);
            const securityIndex = calculateSecurityIndex();
            const healthIndex = calculateHealthIndex();
            const greenCount = (greenState.garden.stats && greenState.garden.stats.count) ? greenState.garden.stats.count : 0;
            const verticalCount = (greenState.vertical.stats && greenState.vertical.stats.count) ? greenState.vertical.stats.count : 0;
            const greenCoverage = buildings.length > 0 ? Math.max(0, Math.min(100, ((greenCount + (verticalCount * 0.5)) / buildings.length) * 100)) : 0;
            let socialPerformance = Math.round((securityIndex + healthIndex + greenCoverage) / 3);
            if (state && state.activeScenario && state.activeScenario.green) {
                socialPerformance = Math.min(100, socialPerformance + 5);
            }
            const renewableGen = ((greenState.solar.active && greenState.solar.stats && greenState.solar.stats.energy) ? greenState.solar.stats.energy : 0) + ((energyState.wind.active && energyState.wind.capacity) ? energyState.wind.capacity : 0);
            const totalEnergy = base.totalEnergy || 0;
            const renewableShare = totalEnergy > 0 ? Math.max(0, Math.min(1, renewableGen / totalEnergy)) : 0;
            const visibleVehicles = Array.isArray(cars) ? cars.filter(c => c && c.visible) : [];
            const busCount = visibleVehicles.filter(c => c.userData && c.userData.vehicleType === 'bus').length;
            let busShare = visibleVehicles.length > 0 ? busCount / visibleVehicles.length : 0;
            if (state && state.activeScenario && state.activeScenario.traffic && visibleVehicles.length === 0) {
                busShare = 0.6;
            }
            let supplierPerformance = Math.round(Math.max(0, Math.min(100, ((renewableShare * 100) * 0.7) + ((busShare * 100) * 0.3))));
            if (state && state.activeScenario && state.activeScenario.green) {
                supplierPerformance = Math.min(100, supplierPerformance + 3);
            }
            const transitMeshCount = Array.isArray(transitRouteMeshes) ? transitRouteMeshes.length : 0;
            let transitScore = Math.max(0, Math.min(100, (transitMeshCount / 10) * 100));
            if (state && state.activeScenario && state.activeScenario.traffic) {
                transitScore = Math.min(100, transitScore + 10);
            }
            const economyIndex = calculateEconomyIndex();
            let destinationManagement = Math.round((securityIndex + economyIndex + transitScore) / 3);
            if (state && state.activeScenario && state.activeScenario.green) {
                destinationManagement = Math.min(100, destinationManagement + 2);
            }
            const gdsTotal = Math.round((destinationManagement + supplierPerformance + socialPerformance + environmentalPerformance) / 4);
            return {
                total: gdsTotal,
                gds: {
                    destinationManagement,
                    supplierPerformance,
                    socialPerformance,
                    environmentalPerformance
                }
            };
        }
        // Removed GDS-related indices for police-only version
        // Function to update stats panel
        // New Detailed Stats Calculation
        function calculateDetailedStats() {
            let totalPopulation = 0;
            let totalCapacity = 0;
            let totalJobs = 0;
            let commercialCount = 0;
            let totalPower = 0;
            let totalWater = 0;
            let totalAirQuality = 0;
            let greenSpace = 0;

            buildings.forEach(b => {
                const type = b.userData.type || "";
                
                // Estimate stats if not present
                if (!b.userData.stats) {
                    let pop = 0;
                    let cap = 0;
                    let jobs = 0;
                    
                    if (type.includes("Residential") || type.includes("Housing") || type.includes("Apartments") || type.includes("Condo")) {
                        pop = Math.floor(Math.random() * 50) + 10;
                        cap = pop + Math.floor(Math.random() * 20);
                    } else if (type.includes("Office") || type.includes("Corporate") || type.includes("Hotel") || type.includes("Retail") || type.includes("Shops")) {
                        jobs = Math.floor(Math.random() * 100) + 20;
                        commercialCount++;
                    }
                    
                    b.userData.stats = {
                        population: pop,
                        capacity: cap,
                        jobs: jobs
                    };
                }
                
                totalPopulation += b.userData.stats.population;
                totalCapacity += b.userData.stats.capacity;
                totalJobs += b.userData.stats.jobs;
                
                // Energy is 0-100 inverted efficiency? 
                // userData.energy is random 0-100. Let's assume it's usage.
                totalPower += b.userData.energy; 
                totalWater += b.userData.pollution; // Pollution as proxy for water usage/waste
            });
            
            // Adjust Power Stats with Renewable Generation
            let renewableGen = 0;
            if (greenState.solar.active) renewableGen += greenState.solar.stats.energy;
            if (energyState.wind.active) renewableGen += energyState.wind.capacity;
            
            // Net Power Demand (can be negative if surplus)
            let netPower = totalPower - renewableGen;
            if (energyState.battery.active && netPower < 0) {
                 // Store surplus, so demand effectively 0 (or charging)
                 // For stats, we just show consumption, maybe separate generation?
                 // Let's just reduce the "Power Grid Load" shown
            }
            
            const cityStats = calculateCityStats(); // Use existing function for efficiency/pollution
            
            return {
                population: totalPopulation,
                capacity: totalCapacity,
                jobs: totalJobs,
                commercial: commercialCount,
                power: totalPower, // MW
                water: totalWater * 1.5, // ML
                air: cityStats.pollution, // "Pollution Score" is actually cleanliness (100 = clean)
                green: Math.round(cityStats.pollution * 0.4 + 10) // Correlated with clean air
            };
        }

        // AI Report Generation
        async function generateAIReport() {
            const apiKey = document.getElementById('openai-api-key').value;
            const outputDiv = document.getElementById('ai-report-output');
            
            if (!apiKey) {
                outputDiv.innerText = "Error: Please enter OpenAI API Key.";
                return;
            }
            
            outputDiv.innerText = "Analyzing city data...";
            
            const stats = calculateDetailedStats();
            const cityStats = calculateCityStats();
            
            const prompt = `You are a city planner AI. Analyze this city data:
            Population: ${stats.population} / ${stats.capacity}
            Jobs: ${stats.jobs}
            Power Usage: ${stats.power} MW
            Water Demand: ${stats.water} ML
            Air Quality Index: ${stats.air}%
            Sustainability Index: ${cityStats.total}%
            
            Provide a 3-sentence summary of the city's status and 3 bullet point recommendations. Use a sci-fi/cyberpunk tone.`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [{ role: "user", content: prompt }],
                        max_tokens: 150
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    outputDiv.innerText = "Error: " + data.error.message;
                } else {
                    outputDiv.innerText = data.choices[0].message.content;
                }
            } catch (error) {
                outputDiv.innerText = "Connection Error: " + error.message;
            }
        }

        function updateStats() {
            // Update building count
            document.getElementById('stat-buildings').innerText = buildings.length;

            // Update vehicle count (only visible cars)
            const visibleCars = cars.filter(car => car.visible).length;
            document.getElementById('stat-vehicles').innerText = visibleCars;

            // Update time display
            const hours = Math.floor(timeOfDay * 24);
            const minutes = Math.floor((timeOfDay * 24 - hours) * 60);
            const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
            const period = hours < 12 ? 'AM' : 'PM';
            const displayMinutes = minutes.toString().padStart(2, '0');
            document.getElementById('stat-time').innerText = `${displayHours}:${displayMinutes}`;
            document.getElementById('stat-period').innerText = period;

            // Update weather
            const weatherNames = {
                'clear': 'Clear',
                'overcast': 'Cloudy',
                'rain': 'Rainy'
            };
            document.getElementById('stat-weather').innerText = weatherNames[weatherState.current] || 'Clear';

            // Update city statistics
            const cityStats = calculateCityStats();

            // NEW: Update Detailed Stats
            const detailedStats = calculateDetailedStats();
            
            document.getElementById('metric-population').innerText = detailedStats.population.toLocaleString();
            document.getElementById('metric-capacity').innerText = detailedStats.capacity.toLocaleString();
            document.getElementById('metric-jobs').innerText = detailedStats.jobs.toLocaleString();
            document.getElementById('metric-commercial').innerText = detailedStats.commercial.toLocaleString();
            document.getElementById('metric-power').innerText = detailedStats.power.toLocaleString() + " MW";
            document.getElementById('metric-water').innerText = Math.round(detailedStats.water).toLocaleString() + " ML";
            document.getElementById('metric-air').innerText = detailedStats.air + "%";
            document.getElementById('metric-green').innerText = detailedStats.green + "%";

            // Energy Efficiency
            document.getElementById('city-energy-value').innerText = cityStats.energy + '%';
            const energyBar = document.getElementById('city-energy-bar');
            energyBar.style.width = cityStats.energy + '%';
            energyBar.style.background = cityStats.energy > 70 ? 'var(--success)' :
                cityStats.energy > 40 ? 'var(--warning)' : 'var(--danger)';

            // Pollution Output (inverted - lower pollution = higher score)
            document.getElementById('city-pollution-value').innerText = cityStats.pollution + '%';
            const pollutionBar = document.getElementById('city-pollution-bar');
            pollutionBar.style.width = cityStats.pollution + '%';
            pollutionBar.style.background = cityStats.pollution > 70 ? 'var(--success)' :
                cityStats.pollution > 40 ? 'var(--warning)' : 'var(--danger)';

            // Security Coverage (tinggi = baik)
            const security = calculateSecurityIndex();
            const secValEl = document.getElementById('city-security-value');
            const secBarEl = document.getElementById('city-security-bar');
            if (secValEl && secBarEl) {
                secValEl.innerText = security + '%';
                secBarEl.style.width = security + '%';
                secBarEl.style.background = security > 70 ? 'var(--success)' :
                    security > 40 ? 'var(--warning)' : 'var(--danger)';
            }

            // Total Score
            document.getElementById('city-total-score').innerText = cityStats.total + '%';
        }

        // --- 6. ANIMASI LOOP UTAMA ---
        // (timeOfDay and weatherState moved up before createCity() call)

        function initWeatherSystems() {
            createCloudLayer();
            createRainSystem();
        }

        function createCloudLayer() {
            const cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xd8d8e0,
                transparent: true,
                opacity: 0.0,
                depthWrite: false
            });

            const radius = config.gridSize * config.cellSize * 0.8;
            for (let i = 0; i < 16; i++) {
                const geo = new THREE.CircleGeometry(THREE.MathUtils.randFloat(radius * 0.2, radius * 0.4), 32);
                const mesh = new THREE.Mesh(geo, cloudMaterial.clone());
                const angle = Math.random() * Math.PI * 2;
                const dist = THREE.MathUtils.randFloat(radius * 0.1, radius * 0.7);
                mesh.position.set(Math.cos(angle) * dist, 450 + Math.random() * 80, Math.sin(angle) * dist);
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.z = Math.random() * 0.5 - 0.25;
                scene.add(mesh);
                cloudMeshes.push(mesh);
            }
        }

        function createRainSystem() {
            const areaSize = config.gridSize * config.cellSize * config.weather.rainAreaMultiplier;
            const rainGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(config.weather.rainDropCount * 3);
            const speeds = new Float32Array(config.weather.rainDropCount);

            for (let i = 0; i < config.weather.rainDropCount; i++) {
                const ix = i * 3;
                positions[ix] = (Math.random() - 0.5) * areaSize;
                positions[ix + 1] = THREE.MathUtils.randFloat(80, 220);
                positions[ix + 2] = (Math.random() - 0.5) * areaSize;
                speeds[i] = THREE.MathUtils.randFloat(80, 140);
            }

            rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainGeo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));

            const rainMat = new THREE.PointsMaterial({
                color: 0x99c9ff,
                size: 0.9,            // Tetesan sedikit lebih besar agar jelas
                transparent: true,
                opacity: 0.0,
                depthWrite: false
            });

            const rainPoints = new THREE.Points(rainGeo, rainMat);
            rainPoints.frustumCulled = false;
            scene.add(rainPoints);
            raindrops.push(rainPoints);
        }

        function updateWeather(delta) {
            const cfg = config.weather;
            weatherState.timer += delta;

            // Ganti tipe cuaca setiap beberapa detik
            if (weatherState.timer > cfg.changeIntervalSeconds) {
                weatherState.timer = 0;
                const types = ['clear', 'overcast', 'rain'];
                let next = weatherState.current;
                while (next === weatherState.current) {
                    next = types[Math.floor(Math.random() * types.length)];
                }
                weatherState.current = next;
            }

            // Target faktor untuk tiap tipe cuaca
            let targetCloud = 0, targetRain = 0, targetDarken = 0;
            if (weatherState.current === 'overcast') {
                targetCloud = 1;
                targetRain = 0;
                targetDarken = cfg.cloudDarkenStrength;
            } else if (weatherState.current === 'rain') {
                targetCloud = 1;
                targetRain = 1;
                targetDarken = cfg.rainDarkenStrength;
            }

            const lerpSpeed = 0.7 * delta; // Perubahan cuaca sedikit lebih cepat agar terasa dinamis
            weatherState.cloudFactor += (targetCloud - weatherState.cloudFactor) * lerpSpeed;
            weatherState.rainFactor += (targetRain - weatherState.rainFactor) * lerpSpeed;
            weatherState.darkenFactor += (targetDarken - weatherState.darkenFactor) * lerpSpeed;

            // Update awan
            const targetCloudOpacity = cfg.maxCloudOpacity * weatherState.cloudFactor;
            cloudMeshes.forEach((m, i) => {
                const material = m.material;
                material.opacity += (targetCloudOpacity - material.opacity) * 0.1;
                // Gerakkan awan perlahan
                m.position.x += 4 * delta * (i % 2 === 0 ? 1 : -1);
            });

            // Update hujan
            raindrops.forEach(points => {
                const positions = points.geometry.attributes.position;
                const speeds = points.geometry.attributes.speed;
                const area = config.gridSize * config.cellSize * cfg.rainAreaMultiplier;

                for (let i = 0; i < positions.count; i++) {
                    const iy = i * 3 + 1;
                    positions.array[iy] -= speeds.array[i] * delta * (0.4 + 0.6 * weatherState.rainFactor);
                    if (positions.array[iy] < 0) {
                        positions.array[iy] = THREE.MathUtils.randFloat(120, 220);
                        const ix = i * 3;
                        const iz = i * 3 + 2;
                        positions.array[ix] = (Math.random() - 0.5) * area;
                        positions.array[iz] = (Math.random() - 0.5) * area;
                    }
                }
                positions.needsUpdate = true;

                const mat = points.material;
                const targetOpacity = 0.9 * weatherState.rainFactor;
                mat.opacity += (targetOpacity - mat.opacity) * 0.2;
            });

            // Update Windmills
            windmills.forEach(wm => {
                wm.mesh.rotation.z -= wm.speed * delta;
            });
        }

        function updateDayNightCycle(delta) {
            // Perbarui waktu siang-malam
            const dayCfg = config.dayNight;
            timeOfDay = (timeOfDay + (delta / dayCfg.fullDaySeconds)) % 1;

            // Ubah sudut matahari berdasarkan waktu (rotasi penuh 360 derajat)
            const sunAngle = timeOfDay * Math.PI * 2; // 0‚Äì2œÄ

            // Y menentukan tinggi matahari di langit
            const sunRadius = 300;
            dirLight.position.set(
                Math.sin(sunAngle) * sunRadius,
                Math.cos(sunAngle) * sunRadius,
                100
            );

            // Faktor siang: 0 saat malam, 1 saat siang penuh (matahari di atas)
            const dayFactorRaw = (dirLight.position.y / sunRadius + 1) / 2; // map y (-r..r) ‚Üí (0..1)
            const dayFactor = THREE.MathUtils.clamp(dayFactorRaw, 0, 1);
            lastDayFactor = dayFactor; // Update global state

            // Intensitas matahari & ambient bergantung pada siang/malam
            const weatherLightFactor = 1 - (weatherState.darkenFactor * 0.6); // Cuaca gelap mengurangi intensitas cahaya
            const sunIntensity = THREE.MathUtils.lerp(dayCfg.minSunIntensity, dayCfg.maxSunIntensity, dayFactor) * weatherLightFactor;
            dirLight.intensity = sunIntensity;

            const ambientIntensity = THREE.MathUtils.lerp(dayCfg.minAmbientIntensity, dayCfg.maxAmbientIntensity, dayFactor) * weatherLightFactor;
            ambientLight.intensity = ambientIntensity;
            hemiLight.intensity = 0.4 + dayFactor * 0.6;

            // Lampu neon kota lebih terang saat malam
            const nightFactor = 1 - dayFactor;
            pointLight.intensity = 0.4 + nightFactor * 1.2;
            secondaryLight.intensity = 0.3 + nightFactor * 1.0;

            // Nyalakan lampu jalan saat malam, matikan saat siang
            const lampIntensity = THREE.MathUtils.lerp(0.0, 1.4, nightFactor);
            const lampEmissive = THREE.MathUtils.lerp(0.0, 1.6, nightFactor);
            lampLights.forEach(light => {
                light.intensity = lampIntensity;
            });
            lampposts.forEach(l => {
                if (l.head && l.head.material) {
                    l.head.material.emissive = new THREE.Color(0xfff2b3);
                    l.head.material.emissiveIntensity = lampEmissive;
                }
            });

            // Interpolasi warna langit (siang ‚Üí malam), dengan penggelapan saat berawan/hujan
            const overcastTint = new THREE.Color(0x7a7a85);
            const adjustedDaySky = daySkyColor.clone().lerp(overcastTint, weatherState.cloudFactor * dayFactor);
            scene.background.copy(nightSkyColor).lerp(adjustedDaySky, dayFactor);

            lastDayFactor = dayFactor;

            const targetWindowOpacity = THREE.MathUtils.lerp(0.25, 0.95, nightFactor);
            windowMaterial.opacity += (targetWindowOpacity - windowMaterial.opacity) * 0.05;
            const targetSkyscraperWindowOpacity = THREE.MathUtils.lerp(0.18, 0.75, nightFactor);
            skyscraperWindowMaterial.opacity += (targetSkyscraperWindowOpacity - skyscraperWindowMaterial.opacity) * 0.05;

            // Tingkatkan intensitas cahaya jendela di malam hari
            buildings.forEach(b => {
                if (!b.material || !b.userData) return;
                const targetIntensity = nightFactor * (b.userData.windowIntensity || 0);
                // Lerping agar perubahan halus
                b.material.emissiveIntensity += (targetIntensity - b.material.emissiveIntensity) * 0.05;
            });
        }

        function updateBloom(delta) {
            const nightFactor = 1 - Math.max(0, lastDayFactor);
            let targetStrength = 0.3 + (nightFactor * 1.8);
            bloomState.cooldown -= delta;
            if (bloomState.cooldown <= 0) {
                bloomState.pulseRemaining = bloomState.pulseDuration;
                bloomState.cooldown = 10 + Math.random() * 20;
            }
            if (bloomState.pulseRemaining > 0) {
                const t = 1 - (bloomState.pulseRemaining / bloomState.pulseDuration);
                targetStrength += 0.4 * Math.sin(Math.PI * t);
                bloomState.pulseRemaining -= delta;
            }
            bloomPass.strength += (targetStrength - bloomPass.strength) * 0.05;
            bloomPass.radius = 0.4 + (nightFactor * 0.4);
            bloomPass.threshold = 0.6;
        }

        function animate() {
            requestAnimationFrame(animate); // Panggil fungsi ini terus menerus (60fps)
            const delta = clock.getDelta();
            const time = Date.now() * 0.001; // Waktu sekarang dalam detik

            // Update camera movement with WASD
            updateCameraMovement(delta);

            // Perbarui siklus siang-malam
            updateDayNightCycle(delta);
            // Perbarui cuaca dinamis
            updateWeather(delta);
            updateBloom(delta);
            // Update stats panel
            updateStats();

            // Gerakkan lampu hias berputar-putar
            pointLight.position.x = Math.sin(time * 0.7) * 100;
            pointLight.position.z = Math.cos(time * 0.7) * 100;
            secondaryLight.position.x = Math.sin(time * 0.5 + 2) * -120;
            secondaryLight.position.z = Math.cos(time * 0.5 + 2) * -120;

            // Update Airplane
            updateAirplane();

            // Update Transit Meshes (Stations) & Wind Turbines
            transitRouteMeshes.forEach(mesh => {
                if (mesh.userData && mesh.userData.rotate) {
                    const speed = mesh.userData.speed || 0.5;
                    const axis = mesh.userData.axis || 'y';
                    
                    if (axis === 'z') {
                        mesh.rotation.z -= delta * speed;
                    } else {
                        mesh.rotation.y += delta * speed;
                    }
                }
            });

            // ULTRA SMOOTH Car Movement System
            // GRID-BASED Car Movement System (Stays on Roads)
            cars.forEach((car, index) => {
                if (!car.visible) return;

                const ud = car.userData;
                const offset = (config.gridSize * config.cellSize) / 2;

                // Helper function to check if grid position is a road
                const isRoad = (gx, gz) => {
                    if (gx < 0 || gx >= config.gridSize || gz < 0 || gz >= config.gridSize) return false;
                    return cityRoadMap[gx] && cityRoadMap[gx][gz] === 1;
                };

                // Convert current world position to grid
                const currentGridX = Math.floor((car.position.x + offset) / config.cellSize);
                const currentGridZ = Math.floor((car.position.z + offset) / config.cellSize);

                // Update stored grid position
                ud.gridX = currentGridX;
                ud.gridZ = currentGridZ;

                // Calculate target world position from grid
                let targetWorldX = (ud.targetGridX * config.cellSize) - offset;
                let targetWorldZ = (ud.targetGridZ * config.cellSize) - offset;

                // Apply lane offset based on current axis
                if (ud.axis === 'z') {
                    targetWorldX += ud.laneOffset;
                } else {
                    targetWorldZ += ud.laneOffsetZ;
                }

                // Check if we've reached the current target cell
                const distToTarget = Math.sqrt(
                    Math.pow(car.position.x - targetWorldX, 2) +
                    Math.pow(car.position.z - targetWorldZ, 2)
                );

                // If close to target, pick next grid cell
                if (distToTarget < 3) {
                    let nextGridX = ud.targetGridX;
                    let nextGridZ = ud.targetGridZ;

                    // Try to continue in current direction
                    if (ud.axis === 'z') {
                        nextGridZ += ud.direction;
                    } else {
                        nextGridX += ud.direction;
                    }

                    // Check if next cell is valid road
                    if (isRoad(nextGridX, nextGridZ)) {
                        ud.targetGridX = nextGridX;
                        ud.targetGridZ = nextGridZ;
                    } else {
                        // Dead end or turn needed - try perpendicular directions
                        const perpendicular = ud.axis === 'z' ? 'x' : 'z';
                        const options = [];

                        if (perpendicular === 'x') {
                            if (isRoad(currentGridX + 1, currentGridZ)) options.push({ x: 1, z: 0, axis: 'x', dir: 1 });
                            if (isRoad(currentGridX - 1, currentGridZ)) options.push({ x: -1, z: 0, axis: 'x', dir: -1 });
                        } else {
                            if (isRoad(currentGridX, currentGridZ + 1)) options.push({ x: 0, z: 1, axis: 'z', dir: 1 });
                            if (isRoad(currentGridX, currentGridZ - 1)) options.push({ x: 0, z: -1, axis: 'z', dir: -1 });
                        }

                        // Also try continuing straight if we miscalculated
                        if (ud.axis === 'z') {
                            if (isRoad(currentGridX, currentGridZ + ud.direction)) {
                                options.push({ x: 0, z: ud.direction, axis: 'z', dir: ud.direction });
                            }
                        } else {
                            if (isRoad(currentGridX + ud.direction, currentGridZ)) {
                                options.push({ x: ud.direction, z: 0, axis: 'x', dir: ud.direction });
                            }
                        }

                        if (options.length > 0) {
                            // Pick random valid direction
                            const choice = options[Math.floor(Math.random() * options.length)];
                            ud.targetGridX = currentGridX + choice.x;
                            ud.targetGridZ = currentGridZ + choice.z;
                            ud.axis = choice.axis;
                            ud.direction = choice.dir;

                            // Update lane offsets when changing direction
                            const laneOffset = 2.2;
                            if (ud.axis === 'z') {
                                // Moving vertically (North/South)
                                ud.laneOffset = laneOffset * (ud.direction === 1 ? -1 : 1);
                                ud.laneOffsetZ = 0;
                                car.rotation.y = ud.direction === 1 ? 0 : Math.PI;
                            } else {
                                // Moving horizontally (East/West)
                                ud.laneOffset = 0;
                                ud.laneOffsetZ = laneOffset * (ud.direction === 1 ? 1 : -1);
                                car.rotation.y = ud.direction === 1 ? Math.PI / 2 : -Math.PI / 2;
                            }
                        } else {
                            // FIXED: Handle dead end - try all directions including reverse
                            const allOptions = [];

                            // Try all 4 directions
                            if (isRoad(currentGridX + 1, currentGridZ)) allOptions.push({ x: 1, z: 0, axis: 'x', dir: 1 });
                            if (isRoad(currentGridX - 1, currentGridZ)) allOptions.push({ x: -1, z: 0, axis: 'x', dir: -1 });
                            if (isRoad(currentGridX, currentGridZ + 1)) allOptions.push({ x: 0, z: 1, axis: 'z', dir: 1 });
                            if (isRoad(currentGridX, currentGridZ - 1)) allOptions.push({ x: 0, z: -1, axis: 'z', dir: -1 });

                            if (allOptions.length > 0) {
                                // Pick random valid direction from all options
                                const choice = allOptions[Math.floor(Math.random() * allOptions.length)];
                                ud.targetGridX = currentGridX + choice.x;
                                ud.targetGridZ = currentGridZ + choice.z;
                                ud.axis = choice.axis;
                                ud.direction = choice.dir;

                                // Update lane offsets when changing direction
                                const laneOffset = 2.2;
                                if (ud.axis === 'z') {
                                    ud.laneOffset = laneOffset * (ud.direction === 1 ? -1 : 1);
                                    ud.laneOffsetZ = 0;
                                    car.rotation.y = ud.direction === 1 ? 0 : Math.PI;
                                } else {
                                    ud.laneOffset = 0;
                                    ud.laneOffsetZ = laneOffset * (ud.direction === 1 ? 1 : -1);
                                    car.rotation.y = ud.direction === 1 ? Math.PI / 2 : -Math.PI / 2;
                                }
                            } else {
                                // Last resort: stay in current position and wait for next frame
                                // Don't update target, but ensure car keeps moving toward current target
                            }
                        }
                    }
                }

                // Recalculate target world position (may have changed after grid update)
                targetWorldX = (ud.targetGridX * config.cellSize) - offset;
                targetWorldZ = (ud.targetGridZ * config.cellSize) - offset;

                // Apply lane offset based on current axis
                if (ud.axis === 'z') {
                    targetWorldX += ud.laneOffset;
                } else {
                    targetWorldZ += ud.laneOffsetZ;
                }

                // Check for cars ahead in same lane (improved to prevent false stops)
                let closestCarDistance = Infinity;
                let closestCarSpeed = ud.topSpeed;

                for (let i = 0; i < cars.length; i++) {
                    if (i === index || !cars[i].visible) continue;

                    const other = cars[i];
                    const otherUd = other.userData;

                    // Only check cars on same axis and direction
                    if (otherUd.axis !== ud.axis) continue;
                    if (otherUd.direction !== ud.direction) continue;

                    let axisDistance, lateralDistance;

                    if (ud.axis === 'z') {
                        axisDistance = (other.position.z - car.position.z) * ud.direction;
                        lateralDistance = Math.abs(other.position.x - car.position.x);
                    } else {
                        axisDistance = (other.position.x - car.position.x) * ud.direction;
                        lateralDistance = Math.abs(other.position.z - car.position.z);
                    }

                    // More lenient collision detection: larger lateral distance threshold and require car to be moving
                    if (axisDistance > 0.5 && axisDistance < 18 && lateralDistance < 3.5 && otherUd.velocity > 0.01) {
                        if (axisDistance < closestCarDistance) {
                            closestCarDistance = axisDistance;
                            closestCarSpeed = Math.max(otherUd.velocity, ud.topSpeed * 0.1); // Ensure minimum speed reference
                        }
                    }
                }

                // Adaptive speed control - less aggressive to prevent stopping
                let targetSpeed = ud.topSpeed;

                if (closestCarDistance < Infinity && closestCarDistance < 25) {
                    if (closestCarDistance < 4) {
                        // Very close - slow down but ensure minimum speed to prevent stopping
                        targetSpeed = Math.max(ud.topSpeed * 0.2, closestCarSpeed * 0.9);
                    } else if (closestCarDistance < 8) {
                        // Close - moderate slowdown
                        targetSpeed = Math.min(closestCarSpeed * 0.97, ud.topSpeed * 0.65);
                    } else if (closestCarDistance < 12) {
                        // Medium distance - slight slowdown
                        targetSpeed = Math.min(closestCarSpeed * 0.99, ud.topSpeed * 0.8);
                    } else {
                        // Far enough - maintain high speed
                        const factor = (closestCarDistance - 12) / 13; // 12 to 25 distance
                        targetSpeed = ud.topSpeed * (0.8 + factor * 0.2);
                    }
                }

                // Smooth acceleration/braking - ensure minimum speed to prevent stopping
                const minSpeed = ud.topSpeed * 0.08; // Minimum 8% of top speed to prevent complete stops
                if (targetSpeed > ud.velocity) {
                    ud.velocity += ud.acceleration;
                    ud.velocity = Math.min(ud.velocity, targetSpeed);
                } else {
                    ud.velocity -= ud.braking;
                    ud.velocity = Math.max(ud.velocity, Math.max(targetSpeed, minSpeed));
                }

                // Ensure velocity never goes below minimum
                ud.velocity = Math.max(ud.velocity, minSpeed);

                // Move toward target grid cell - always move if there's a valid target
                const dirX = targetWorldX - car.position.x;
                const dirZ = targetWorldZ - car.position.z;
                const dist = Math.sqrt(dirX * dirX + dirZ * dirZ);

                // Always move toward target (changed threshold from 0.1 to 0.01 to prevent stopping)
                if (dist > 0.01) {
                    car.position.x += (dirX / dist) * ud.velocity;
                    car.position.z += (dirZ / dist) * ud.velocity;
                }
            });
            controls.update(); // kontrol kamera
            composer.render(); // render scene ke layar
        }

        // bisa ganti size dengan sendirinya
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
            updateUIScale();
        });

        // Saat halaman selesai dimuat (Startup)
        window.onload = () => {
            animate(); // Mulai loop animasi
            // Animasi Loading Screen hilang
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
                // Animasi kamera zoom in dari jauh
                gsap.to(camera.position, {
                    x: 100,
                    y: 150,
                    z: 100,
                    duration: 2.5,
                    ease: "power2.out"
                });

            }, 1000);
        };   
    </script>
</body>

</html>


